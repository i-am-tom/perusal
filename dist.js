(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.Perusal = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// Generated by psc-bundle 0.11.5
var PS = {};
(function(exports) {
    "use strict";

  exports.arrayMap = function (f) {
    return function (arr) {
      var l = arr.length;
      var result = new Array(l);
      for (var i = 0; i < l; i++) {
        result[i] = f(arr[i]);
      }
      return result;
    };
  };
})(PS["Data.Functor"] = PS["Data.Functor"] || {});
(function(exports) {
  // Generated by purs version 0.11.5
  "use strict";
  var Semigroupoid = function (compose) {
      this.compose = compose;
  };
  var semigroupoidFn = new Semigroupoid(function (f) {
      return function (g) {
          return function (x) {
              return f(g(x));
          };
      };
  });
  var compose = function (dict) {
      return dict.compose;
  };
  exports["Semigroupoid"] = Semigroupoid;
  exports["compose"] = compose;
  exports["semigroupoidFn"] = semigroupoidFn;
})(PS["Control.Semigroupoid"] = PS["Control.Semigroupoid"] || {});
(function(exports) {
  // Generated by purs version 0.11.5
  "use strict";
  var Control_Semigroupoid = PS["Control.Semigroupoid"];        
  var Category = function (Semigroupoid0, id) {
      this.Semigroupoid0 = Semigroupoid0;
      this.id = id;
  };
  var id = function (dict) {
      return dict.id;
  };
  var categoryFn = new Category(function () {
      return Control_Semigroupoid.semigroupoidFn;
  }, function (x) {
      return x;
  });
  exports["Category"] = Category;
  exports["id"] = id;
  exports["categoryFn"] = categoryFn;
})(PS["Control.Category"] = PS["Control.Category"] || {});
(function(exports) {
  // Generated by purs version 0.11.5
  "use strict";
  var Control_Category = PS["Control.Category"];
  var flip = function (f) {
      return function (b) {
          return function (a) {
              return f(a)(b);
          };
      };
  };
  var $$const = function (a) {
      return function (v) {
          return a;
      };
  };
  var applyFlipped = function (x) {
      return function (f) {
          return f(x);
      };
  };
  exports["applyFlipped"] = applyFlipped;
  exports["const"] = $$const;
  exports["flip"] = flip;
})(PS["Data.Function"] = PS["Data.Function"] || {});
(function(exports) {
    "use strict";

  exports.unit = {};
})(PS["Data.Unit"] = PS["Data.Unit"] || {});
(function(exports) {
    "use strict";

  exports.showNumberImpl = function (n) {
    var str = n.toString();
    return isNaN(str + ".0") ? str : str + ".0";
  };

  exports.showStringImpl = function (s) {
    var l = s.length;
    return "\"" + s.replace(
      /[\0-\x1F\x7F"\\]/g, // eslint-disable-line no-control-regex
      function (c, i) {
        switch (c) {
          case "\"":
          case "\\":
            return "\\" + c;
          case "\x07": return "\\a";
          case "\b": return "\\b";
          case "\f": return "\\f";
          case "\n": return "\\n";
          case "\r": return "\\r";
          case "\t": return "\\t";
          case "\v": return "\\v";
        }
        var k = i + 1;
        var empty = k < l && s[k] >= "0" && s[k] <= "9" ? "\\&" : "";
        return "\\" + c.charCodeAt(0).toString(10) + empty;
      }
    ) + "\"";
  };
})(PS["Data.Show"] = PS["Data.Show"] || {});
(function(exports) {
  // Generated by purs version 0.11.5
  "use strict";
  var $foreign = PS["Data.Show"];     
  var Show = function (show) {
      this.show = show;
  };
  var showString = new Show($foreign.showStringImpl);
  var showNumber = new Show($foreign.showNumberImpl);
  var show = function (dict) {
      return dict.show;
  };
  exports["Show"] = Show;
  exports["show"] = show;
  exports["showNumber"] = showNumber;
  exports["showString"] = showString;
})(PS["Data.Show"] = PS["Data.Show"] || {});
(function(exports) {
  // Generated by purs version 0.11.5
  "use strict";
  var $foreign = PS["Data.Unit"];
  var Data_Show = PS["Data.Show"];
  exports["unit"] = $foreign.unit;
})(PS["Data.Unit"] = PS["Data.Unit"] || {});
(function(exports) {
  // Generated by purs version 0.11.5
  "use strict";
  var $foreign = PS["Data.Functor"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Data_Function = PS["Data.Function"];
  var Data_Unit = PS["Data.Unit"];        
  var Functor = function (map) {
      this.map = map;
  };
  var map = function (dict) {
      return dict.map;
  };
  var mapFlipped = function (dictFunctor) {
      return function (fa) {
          return function (f) {
              return map(dictFunctor)(f)(fa);
          };
      };
  };
  var $$void = function (dictFunctor) {
      return map(dictFunctor)(Data_Function["const"](Data_Unit.unit));
  };
  var voidLeft = function (dictFunctor) {
      return function (f) {
          return function (x) {
              return map(dictFunctor)(Data_Function["const"](x))(f);
          };
      };
  };
  var functorFn = new Functor(Control_Semigroupoid.compose(Control_Semigroupoid.semigroupoidFn));
  var functorArray = new Functor($foreign.arrayMap);
  var flap = function (dictFunctor) {
      return function (ff) {
          return function (x) {
              return map(dictFunctor)(function (f) {
                  return f(x);
              })(ff);
          };
      };
  };
  exports["Functor"] = Functor;
  exports["flap"] = flap;
  exports["map"] = map;
  exports["mapFlipped"] = mapFlipped;
  exports["void"] = $$void;
  exports["voidLeft"] = voidLeft;
  exports["functorFn"] = functorFn;
  exports["functorArray"] = functorArray;
})(PS["Data.Functor"] = PS["Data.Functor"] || {});
(function(exports) {
  // Generated by purs version 0.11.5
  "use strict";
  var $foreign = PS["Data.Semigroup"];
  var Data_Unit = PS["Data.Unit"];
  var Data_Void = PS["Data.Void"];        
  var Semigroup = function (append) {
      this.append = append;
  };                                                       
  var append = function (dict) {
      return dict.append;
  };
  exports["Semigroup"] = Semigroup;
  exports["append"] = append;
})(PS["Data.Semigroup"] = PS["Data.Semigroup"] || {});
(function(exports) {
  // Generated by purs version 0.11.5
  "use strict";
  var Data_Functor = PS["Data.Functor"];
  var Data_Semigroup = PS["Data.Semigroup"];        
  var Alt = function (Functor0, alt) {
      this.Functor0 = Functor0;
      this.alt = alt;
  };                                                       
  var alt = function (dict) {
      return dict.alt;
  };
  exports["Alt"] = Alt;
  exports["alt"] = alt;
})(PS["Control.Alt"] = PS["Control.Alt"] || {});
(function(exports) {
    "use strict";

  exports.arrayApply = function (fs) {
    return function (xs) {
      var result = [];
      var n = 0;
      for (var i = 0, l = fs.length; i < l; i++) {
        for (var j = 0, k = xs.length; j < k; j++) {
          result[n++] = fs[i](xs[j]);
        }
      }
      return result;
    };
  };
})(PS["Control.Apply"] = PS["Control.Apply"] || {});
(function(exports) {
  // Generated by purs version 0.11.5
  "use strict";
  var $foreign = PS["Control.Apply"];
  var Control_Category = PS["Control.Category"];
  var Data_Function = PS["Data.Function"];
  var Data_Functor = PS["Data.Functor"];        
  var Apply = function (Functor0, apply) {
      this.Functor0 = Functor0;
      this.apply = apply;
  }; 
  var applyArray = new Apply(function () {
      return Data_Functor.functorArray;
  }, $foreign.arrayApply);
  var apply = function (dict) {
      return dict.apply;
  };
  var applySecond = function (dictApply) {
      return function (a) {
          return function (b) {
              return apply(dictApply)(Data_Functor.map(dictApply.Functor0())(Data_Function["const"](Control_Category.id(Control_Category.categoryFn)))(a))(b);
          };
      };
  };
  var lift2 = function (dictApply) {
      return function (f) {
          return function (a) {
              return function (b) {
                  return apply(dictApply)(Data_Functor.map(dictApply.Functor0())(f)(a))(b);
              };
          };
      };
  };
  exports["Apply"] = Apply;
  exports["apply"] = apply;
  exports["applySecond"] = applySecond;
  exports["lift2"] = lift2;
  exports["applyArray"] = applyArray;
})(PS["Control.Apply"] = PS["Control.Apply"] || {});
(function(exports) {
  // Generated by purs version 0.11.5
  "use strict";
  var Control_Apply = PS["Control.Apply"];
  var Data_Functor = PS["Data.Functor"];
  var Data_Unit = PS["Data.Unit"];        
  var Applicative = function (Apply0, pure) {
      this.Apply0 = Apply0;
      this.pure = pure;
  };
  var pure = function (dict) {
      return dict.pure;
  };
  var liftA1 = function (dictApplicative) {
      return function (f) {
          return function (a) {
              return Control_Apply.apply(dictApplicative.Apply0())(pure(dictApplicative)(f))(a);
          };
      };
  };
  exports["Applicative"] = Applicative;
  exports["liftA1"] = liftA1;
  exports["pure"] = pure;
})(PS["Control.Applicative"] = PS["Control.Applicative"] || {});
(function(exports) {
  // Generated by purs version 0.11.5
  "use strict";
  var Control_Alt = PS["Control.Alt"];
  var Data_Functor = PS["Data.Functor"];        
  var Plus = function (Alt0, empty) {
      this.Alt0 = Alt0;
      this.empty = empty;
  };       
  var empty = function (dict) {
      return dict.empty;
  };
  exports["Plus"] = Plus;
  exports["empty"] = empty;
})(PS["Control.Plus"] = PS["Control.Plus"] || {});
(function(exports) {
  // Generated by purs version 0.11.5
  "use strict";
  var Control_Alt = PS["Control.Alt"];
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Plus = PS["Control.Plus"];
  var Data_Functor = PS["Data.Functor"];        
  var Alternative = function (Applicative0, Plus1) {
      this.Applicative0 = Applicative0;
      this.Plus1 = Plus1;
  };
  exports["Alternative"] = Alternative;
})(PS["Control.Alternative"] = PS["Control.Alternative"] || {});
(function(exports) {
    "use strict";

  exports.arrayBind = function (arr) {
    return function (f) {
      var result = [];
      for (var i = 0, l = arr.length; i < l; i++) {
        Array.prototype.push.apply(result, f(arr[i]));
      }
      return result;
    };
  };
})(PS["Control.Bind"] = PS["Control.Bind"] || {});
(function(exports) {
  // Generated by purs version 0.11.5
  "use strict";
  var $foreign = PS["Control.Bind"];
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Category = PS["Control.Category"];
  var Data_Function = PS["Data.Function"];
  var Data_Functor = PS["Data.Functor"];
  var Data_Unit = PS["Data.Unit"];        
  var Bind = function (Apply0, bind) {
      this.Apply0 = Apply0;
      this.bind = bind;
  };
  var Discard = function (discard) {
      this.discard = discard;
  };
  var discard = function (dict) {
      return dict.discard;
  }; 
  var bindArray = new Bind(function () {
      return Control_Apply.applyArray;
  }, $foreign.arrayBind);
  var bind = function (dict) {
      return dict.bind;
  };
  var bindFlipped = function (dictBind) {
      return Data_Function.flip(bind(dictBind));
  };
  var composeKleisliFlipped = function (dictBind) {
      return function (f) {
          return function (g) {
              return function (a) {
                  return bindFlipped(dictBind)(f)(g(a));
              };
          };
      };
  };
  var composeKleisli = function (dictBind) {
      return function (f) {
          return function (g) {
              return function (a) {
                  return bind(dictBind)(f(a))(g);
              };
          };
      };
  };
  var discardUnit = new Discard(function (dictBind) {
      return bind(dictBind);
  });
  exports["Bind"] = Bind;
  exports["Discard"] = Discard;
  exports["bind"] = bind;
  exports["bindFlipped"] = bindFlipped;
  exports["composeKleisli"] = composeKleisli;
  exports["composeKleisliFlipped"] = composeKleisliFlipped;
  exports["discard"] = discard;
  exports["bindArray"] = bindArray;
  exports["discardUnit"] = discardUnit;
})(PS["Control.Bind"] = PS["Control.Bind"] || {});
(function(exports) {
  // Generated by purs version 0.11.5
  "use strict";
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Bind = PS["Control.Bind"];
  var Data_Functor = PS["Data.Functor"];
  var Data_Unit = PS["Data.Unit"];        
  var Monad = function (Applicative0, Bind1) {
      this.Applicative0 = Applicative0;
      this.Bind1 = Bind1;
  };
  var ap = function (dictMonad) {
      return function (f) {
          return function (a) {
              return Control_Bind.bind(dictMonad.Bind1())(f)(function (v) {
                  return Control_Bind.bind(dictMonad.Bind1())(a)(function (v1) {
                      return Control_Applicative.pure(dictMonad.Applicative0())(v(v1));
                  });
              });
          };
      };
  };
  exports["Monad"] = Monad;
  exports["ap"] = ap;
})(PS["Control.Monad"] = PS["Control.Monad"] || {});
(function(exports) {
    "use strict";

  exports.pureE = function (a) {
    return function () {
      return a;
    };
  };

  exports.bindE = function (a) {
    return function (f) {
      return function () {
        return f(a())();
      };
    };
  };

  exports.runPure = function (f) {
    return f();
  };
})(PS["Control.Monad.Eff"] = PS["Control.Monad.Eff"] || {});
(function(exports) {
  // Generated by purs version 0.11.5
  "use strict";
  var $foreign = PS["Control.Monad.Eff"];
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Bind = PS["Control.Bind"];
  var Control_Monad = PS["Control.Monad"];
  var Data_Functor = PS["Data.Functor"];
  var Data_Unit = PS["Data.Unit"];        
  var monadEff = new Control_Monad.Monad(function () {
      return applicativeEff;
  }, function () {
      return bindEff;
  });
  var bindEff = new Control_Bind.Bind(function () {
      return applyEff;
  }, $foreign.bindE);
  var applyEff = new Control_Apply.Apply(function () {
      return functorEff;
  }, Control_Monad.ap(monadEff));
  var applicativeEff = new Control_Applicative.Applicative(function () {
      return applyEff;
  }, $foreign.pureE);
  var functorEff = new Data_Functor.Functor(Control_Applicative.liftA1(applicativeEff));
  exports["functorEff"] = functorEff;
  exports["applyEff"] = applyEff;
  exports["applicativeEff"] = applicativeEff;
  exports["bindEff"] = bindEff;
  exports["monadEff"] = monadEff;
  exports["runPure"] = $foreign.runPure;
})(PS["Control.Monad.Eff"] = PS["Control.Monad.Eff"] || {});
(function(exports) {
  // Generated by purs version 0.11.5
  "use strict";
  var Control_Category = PS["Control.Category"];
  var Control_Monad = PS["Control.Monad"];
  var Control_Monad_Eff = PS["Control.Monad.Eff"];        
  var MonadEff = function (Monad0, liftEff) {
      this.Monad0 = Monad0;
      this.liftEff = liftEff;
  };
  var monadEffEff = new MonadEff(function () {
      return Control_Monad_Eff.monadEff;
  }, Control_Category.id(Control_Category.categoryFn));
  var liftEff = function (dict) {
      return dict.liftEff;
  };
  exports["MonadEff"] = MonadEff;
  exports["liftEff"] = liftEff;
  exports["monadEffEff"] = monadEffEff;
})(PS["Control.Monad.Eff.Class"] = PS["Control.Monad.Eff.Class"] || {});
(function(exports) {
  // Generated by purs version 0.11.5
  "use strict";
  var Control_Category = PS["Control.Category"];        
  var Bifunctor = function (bimap) {
      this.bimap = bimap;
  };
  var bimap = function (dict) {
      return dict.bimap;
  };
  var lmap = function (dictBifunctor) {
      return function (f) {
          return bimap(dictBifunctor)(f)(Control_Category.id(Control_Category.categoryFn));
      };
  };
  exports["Bifunctor"] = Bifunctor;
  exports["bimap"] = bimap;
  exports["lmap"] = lmap;
})(PS["Data.Bifunctor"] = PS["Data.Bifunctor"] || {});
(function(exports) {
    "use strict";

  exports.refEq = function (r1) {
    return function (r2) {
      return r1 === r2;
    };
  };
})(PS["Data.Eq"] = PS["Data.Eq"] || {});
(function(exports) {
  // Generated by purs version 0.11.5
  "use strict";
  var $foreign = PS["Data.Eq"];
  var Data_Unit = PS["Data.Unit"];
  var Data_Void = PS["Data.Void"];        
  var Eq = function (eq) {
      this.eq = eq;
  };                                    
  var eqNumber = new Eq($foreign.refEq);
  var eqInt = new Eq($foreign.refEq);
  var eq = function (dict) {
      return dict.eq;
  };
  exports["Eq"] = Eq;
  exports["eq"] = eq;
  exports["eqInt"] = eqInt;
  exports["eqNumber"] = eqNumber;
})(PS["Data.Eq"] = PS["Data.Eq"] || {});
(function(exports) {
    "use strict";

  exports.foldrArray = function (f) {
    return function (init) {
      return function (xs) {
        var acc = init;
        var len = xs.length;
        for (var i = len - 1; i >= 0; i--) {
          acc = f(xs[i])(acc);
        }
        return acc;
      };
    };
  };

  exports.foldlArray = function (f) {
    return function (init) {
      return function (xs) {
        var acc = init;
        var len = xs.length;
        for (var i = 0; i < len; i++) {
          acc = f(acc)(xs[i]);
        }
        return acc;
      };
    };
  };
})(PS["Data.Foldable"] = PS["Data.Foldable"] || {});
(function(exports) {
  // Generated by purs version 0.11.5
  "use strict";
  var Control_Alt = PS["Control.Alt"];
  var Control_Alternative = PS["Control.Alternative"];
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Bind = PS["Control.Bind"];
  var Control_Monad = PS["Control.Monad"];
  var Control_Plus = PS["Control.Plus"];
  var Data_Functor = PS["Data.Functor"];
  var Data_Unit = PS["Data.Unit"];        
  var MonadZero = function (Alternative1, Monad0) {
      this.Alternative1 = Alternative1;
      this.Monad0 = Monad0;
  }; 
  var guard = function (dictMonadZero) {
      return function (v) {
          if (v) {
              return Control_Applicative.pure((dictMonadZero.Alternative1()).Applicative0())(Data_Unit.unit);
          };
          if (!v) {
              return Control_Plus.empty((dictMonadZero.Alternative1()).Plus1());
          };
          throw new Error("Failed pattern match at Control.MonadZero line 55, column 1 - line 55, column 23: " + [ v.constructor.name ]);
      };
  };
  exports["MonadZero"] = MonadZero;
  exports["guard"] = guard;
})(PS["Control.MonadZero"] = PS["Control.MonadZero"] || {});
(function(exports) {
  // Generated by purs version 0.11.5
  "use strict";
  var otherwise = true;
  exports["otherwise"] = otherwise;
})(PS["Data.Boolean"] = PS["Data.Boolean"] || {});
(function(exports) {
    "use strict";

  exports.unsafeCompareImpl = function (lt) {
    return function (eq) {
      return function (gt) {
        return function (x) {
          return function (y) {
            return x < y ? lt : x === y ? eq : gt;
          };
        };
      };
    };
  };
})(PS["Data.Ord.Unsafe"] = PS["Data.Ord.Unsafe"] || {});
(function(exports) {
  // Generated by purs version 0.11.5
  "use strict";
  var Data_Eq = PS["Data.Eq"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Show = PS["Data.Show"];        
  var LT = (function () {
      function LT() {

      };
      LT.value = new LT();
      return LT;
  })();
  var GT = (function () {
      function GT() {

      };
      GT.value = new GT();
      return GT;
  })();
  var EQ = (function () {
      function EQ() {

      };
      EQ.value = new EQ();
      return EQ;
  })();
  exports["LT"] = LT;
  exports["GT"] = GT;
  exports["EQ"] = EQ;
})(PS["Data.Ordering"] = PS["Data.Ordering"] || {});
(function(exports) {
  // Generated by purs version 0.11.5
  "use strict";
  var $foreign = PS["Data.Ord.Unsafe"];
  var Data_Ordering = PS["Data.Ordering"];        
  var unsafeCompare = $foreign.unsafeCompareImpl(Data_Ordering.LT.value)(Data_Ordering.EQ.value)(Data_Ordering.GT.value);
  exports["unsafeCompare"] = unsafeCompare;
})(PS["Data.Ord.Unsafe"] = PS["Data.Ord.Unsafe"] || {});
(function(exports) {
  // Generated by purs version 0.11.5
  "use strict";
  var $foreign = PS["Data.Ord"];
  var Data_Eq = PS["Data.Eq"];
  var Data_Function = PS["Data.Function"];
  var Data_Ord_Unsafe = PS["Data.Ord.Unsafe"];
  var Data_Ordering = PS["Data.Ordering"];
  var Data_Ring = PS["Data.Ring"];
  var Data_Semiring = PS["Data.Semiring"];
  var Data_Unit = PS["Data.Unit"];
  var Data_Void = PS["Data.Void"];        
  var Ord = function (Eq0, compare) {
      this.Eq0 = Eq0;
      this.compare = compare;
  }; 
  var ordNumber = new Ord(function () {
      return Data_Eq.eqNumber;
  }, Data_Ord_Unsafe.unsafeCompare);
  var ordInt = new Ord(function () {
      return Data_Eq.eqInt;
  }, Data_Ord_Unsafe.unsafeCompare);
  var compare = function (dict) {
      return dict.compare;
  };
  var greaterThan = function (dictOrd) {
      return function (a1) {
          return function (a2) {
              var v = compare(dictOrd)(a1)(a2);
              if (v instanceof Data_Ordering.GT) {
                  return true;
              };
              return false;
          };
      };
  };
  var lessThan = function (dictOrd) {
      return function (a1) {
          return function (a2) {
              var v = compare(dictOrd)(a1)(a2);
              if (v instanceof Data_Ordering.LT) {
                  return true;
              };
              return false;
          };
      };
  };
  var between = function (dictOrd) {
      return function (low) {
          return function (hi) {
              return function (x) {
                  if (lessThan(dictOrd)(x)(low)) {
                      return false;
                  };
                  if (greaterThan(dictOrd)(x)(hi)) {
                      return false;
                  };
                  return true;
              };
          };
      };
  };
  exports["Ord"] = Ord;
  exports["between"] = between;
  exports["compare"] = compare;
  exports["greaterThan"] = greaterThan;
  exports["lessThan"] = lessThan;
  exports["ordInt"] = ordInt;
  exports["ordNumber"] = ordNumber;
})(PS["Data.Ord"] = PS["Data.Ord"] || {});
(function(exports) {
  // Generated by purs version 0.11.5
  "use strict";
  var Data_Boolean = PS["Data.Boolean"];
  var Data_Eq = PS["Data.Eq"];
  var Data_EuclideanRing = PS["Data.EuclideanRing"];
  var Data_Function = PS["Data.Function"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Ordering = PS["Data.Ordering"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Unit = PS["Data.Unit"];
  var Prelude = PS["Prelude"];
  var mempty = function (dict) {
      return dict.mempty;
  };
  exports["mempty"] = mempty;
})(PS["Data.Monoid"] = PS["Data.Monoid"] || {});
(function(exports) {
  // Generated by purs version 0.11.5
  "use strict";
  var Control_Alt = PS["Control.Alt"];
  var Control_Alternative = PS["Control.Alternative"];
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Bind = PS["Control.Bind"];
  var Control_Category = PS["Control.Category"];
  var Control_Extend = PS["Control.Extend"];
  var Control_Monad = PS["Control.Monad"];
  var Control_MonadZero = PS["Control.MonadZero"];
  var Control_Plus = PS["Control.Plus"];
  var Data_Bounded = PS["Data.Bounded"];
  var Data_Eq = PS["Data.Eq"];
  var Data_Function = PS["Data.Function"];
  var Data_Functor = PS["Data.Functor"];
  var Data_Functor_Invariant = PS["Data.Functor.Invariant"];
  var Data_Monoid = PS["Data.Monoid"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Ordering = PS["Data.Ordering"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Show = PS["Data.Show"];
  var Data_Unit = PS["Data.Unit"];
  var Prelude = PS["Prelude"];        
  var Nothing = (function () {
      function Nothing() {

      };
      Nothing.value = new Nothing();
      return Nothing;
  })();
  var Just = (function () {
      function Just(value0) {
          this.value0 = value0;
      };
      Just.create = function (value0) {
          return new Just(value0);
      };
      return Just;
  })();
  var maybe = function (v) {
      return function (v1) {
          return function (v2) {
              if (v2 instanceof Nothing) {
                  return v;
              };
              if (v2 instanceof Just) {
                  return v1(v2.value0);
              };
              throw new Error("Failed pattern match at Data.Maybe line 220, column 1 - line 220, column 22: " + [ v.constructor.name, v1.constructor.name, v2.constructor.name ]);
          };
      };
  };
  var isNothing = maybe(true)(Data_Function["const"](false));
  var isJust = maybe(false)(Data_Function["const"](true));
  var functorMaybe = new Data_Functor.Functor(function (v) {
      return function (v1) {
          if (v1 instanceof Just) {
              return new Just(v(v1.value0));
          };
          return Nothing.value;
      };
  });
  var fromJust = function (dictPartial) {
      return function (v) {
          var __unused = function (dictPartial1) {
              return function ($dollar34) {
                  return $dollar34;
              };
          };
          return __unused(dictPartial)((function () {
              if (v instanceof Just) {
                  return v.value0;
              };
              throw new Error("Failed pattern match at Data.Maybe line 271, column 1 - line 271, column 21: " + [ v.constructor.name ]);
          })());
      };
  };
  var applyMaybe = new Control_Apply.Apply(function () {
      return functorMaybe;
  }, function (v) {
      return function (v1) {
          if (v instanceof Just) {
              return Data_Functor.map(functorMaybe)(v.value0)(v1);
          };
          if (v instanceof Nothing) {
              return Nothing.value;
          };
          throw new Error("Failed pattern match at Data.Maybe line 69, column 3 - line 69, column 31: " + [ v.constructor.name, v1.constructor.name ]);
      };
  });
  var bindMaybe = new Control_Bind.Bind(function () {
      return applyMaybe;
  }, function (v) {
      return function (v1) {
          if (v instanceof Just) {
              return v1(v.value0);
          };
          if (v instanceof Nothing) {
              return Nothing.value;
          };
          throw new Error("Failed pattern match at Data.Maybe line 128, column 3 - line 128, column 24: " + [ v.constructor.name, v1.constructor.name ]);
      };
  });
  var applicativeMaybe = new Control_Applicative.Applicative(function () {
      return applyMaybe;
  }, Just.create);
  var monadMaybe = new Control_Monad.Monad(function () {
      return applicativeMaybe;
  }, function () {
      return bindMaybe;
  });
  var altMaybe = new Control_Alt.Alt(function () {
      return functorMaybe;
  }, function (v) {
      return function (v1) {
          if (v instanceof Nothing) {
              return v1;
          };
          return v;
      };
  });
  var plusMaybe = new Control_Plus.Plus(function () {
      return altMaybe;
  }, Nothing.value);
  var alternativeMaybe = new Control_Alternative.Alternative(function () {
      return applicativeMaybe;
  }, function () {
      return plusMaybe;
  });
  var monadZeroMaybe = new Control_MonadZero.MonadZero(function () {
      return alternativeMaybe;
  }, function () {
      return monadMaybe;
  });
  exports["Nothing"] = Nothing;
  exports["Just"] = Just;
  exports["fromJust"] = fromJust;
  exports["isJust"] = isJust;
  exports["isNothing"] = isNothing;
  exports["maybe"] = maybe;
  exports["functorMaybe"] = functorMaybe;
  exports["applyMaybe"] = applyMaybe;
  exports["applicativeMaybe"] = applicativeMaybe;
  exports["altMaybe"] = altMaybe;
  exports["plusMaybe"] = plusMaybe;
  exports["alternativeMaybe"] = alternativeMaybe;
  exports["bindMaybe"] = bindMaybe;
  exports["monadMaybe"] = monadMaybe;
  exports["monadZeroMaybe"] = monadZeroMaybe;
})(PS["Data.Maybe"] = PS["Data.Maybe"] || {});
(function(exports) {
  // Generated by purs version 0.11.5
  "use strict";
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Data_Function = PS["Data.Function"];
  var Data_Functor = PS["Data.Functor"];
  var Prelude = PS["Prelude"];        
  var Newtype = function (unwrap, wrap) {
      this.unwrap = unwrap;
      this.wrap = wrap;
  };
  var wrap = function (dict) {
      return dict.wrap;
  };
  var unwrap = function (dict) {
      return dict.unwrap;
  };
  exports["Newtype"] = Newtype;
  exports["unwrap"] = unwrap;
  exports["wrap"] = wrap;
})(PS["Data.Newtype"] = PS["Data.Newtype"] || {});
(function(exports) {
  // Generated by purs version 0.11.5
  "use strict";
  var $foreign = PS["Data.Foldable"];
  var Control_Alt = PS["Control.Alt"];
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Bind = PS["Control.Bind"];
  var Control_Category = PS["Control.Category"];
  var Control_Plus = PS["Control.Plus"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Data_Eq = PS["Data.Eq"];
  var Data_Function = PS["Data.Function"];
  var Data_Functor = PS["Data.Functor"];
  var Data_HeytingAlgebra = PS["Data.HeytingAlgebra"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_Maybe_First = PS["Data.Maybe.First"];
  var Data_Maybe_Last = PS["Data.Maybe.Last"];
  var Data_Monoid = PS["Data.Monoid"];
  var Data_Monoid_Additive = PS["Data.Monoid.Additive"];
  var Data_Monoid_Conj = PS["Data.Monoid.Conj"];
  var Data_Monoid_Disj = PS["Data.Monoid.Disj"];
  var Data_Monoid_Dual = PS["Data.Monoid.Dual"];
  var Data_Monoid_Endo = PS["Data.Monoid.Endo"];
  var Data_Monoid_Multiplicative = PS["Data.Monoid.Multiplicative"];
  var Data_Newtype = PS["Data.Newtype"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Ordering = PS["Data.Ordering"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Semiring = PS["Data.Semiring"];
  var Data_Unit = PS["Data.Unit"];
  var Prelude = PS["Prelude"];        
  var Foldable = function (foldMap, foldl, foldr) {
      this.foldMap = foldMap;
      this.foldl = foldl;
      this.foldr = foldr;
  };
  var foldr = function (dict) {
      return dict.foldr;
  };
  var traverse_ = function (dictApplicative) {
      return function (dictFoldable) {
          return function (f) {
              return foldr(dictFoldable)(function ($181) {
                  return Control_Apply.applySecond(dictApplicative.Apply0())(f($181));
              })(Control_Applicative.pure(dictApplicative)(Data_Unit.unit));
          };
      };
  };
  var for_ = function (dictApplicative) {
      return function (dictFoldable) {
          return Data_Function.flip(traverse_(dictApplicative)(dictFoldable));
      };
  };
  var foldl = function (dict) {
      return dict.foldl;
  }; 
  var foldMapDefaultR = function (dictFoldable) {
      return function (dictMonoid) {
          return function (f) {
              return foldr(dictFoldable)(function (x) {
                  return function (acc) {
                      return Data_Semigroup.append(dictMonoid.Semigroup0())(f(x))(acc);
                  };
              })(Data_Monoid.mempty(dictMonoid));
          };
      };
  };
  var foldableArray = new Foldable(function (dictMonoid) {
      return foldMapDefaultR(foldableArray)(dictMonoid);
  }, $foreign.foldlArray, $foreign.foldrArray);
  var foldMap = function (dict) {
      return dict.foldMap;
  };
  exports["Foldable"] = Foldable;
  exports["foldMap"] = foldMap;
  exports["foldMapDefaultR"] = foldMapDefaultR;
  exports["foldl"] = foldl;
  exports["foldr"] = foldr;
  exports["for_"] = for_;
  exports["traverse_"] = traverse_;
  exports["foldableArray"] = foldableArray;
})(PS["Data.Foldable"] = PS["Data.Foldable"] || {});
(function(exports) {
    "use strict";

  // jshint maxparams: 3

  exports.traverseArrayImpl = function () {
    function Cont(fn) {
      this.fn = fn;
    }

    var emptyList = {};

    var ConsCell = function (head, tail) {
      this.head = head;
      this.tail = tail;
    };

    function consList(x) {
      return function (xs) {
        return new ConsCell(x, xs);
      };
    }

    function listToArray(list) {
      var arr = [];
      var xs = list;
      while (xs !== emptyList) {
        arr.push(xs.head);
        xs = xs.tail;
      }
      return arr;
    }

    return function (apply) {
      return function (map) {
        return function (pure) {
          return function (f) {
            var buildFrom = function (x, ys) {
              return apply(map(consList)(f(x)))(ys);
            };

            var go = function (acc, currentLen, xs) {
              if (currentLen === 0) {
                return acc;
              } else {
                var last = xs[currentLen - 1];
                return new Cont(function () {
                  return go(buildFrom(last, acc), currentLen - 1, xs);
                });
              }
            };

            return function (array) {
              var result = go(pure(emptyList), array.length, array);
              while (result instanceof Cont) {
                result = result.fn();
              }

              return map(listToArray)(result);
            };
          };
        };
      };
    };
  }();
})(PS["Data.Traversable"] = PS["Data.Traversable"] || {});
(function(exports) {
  // Generated by purs version 0.11.5
  "use strict";
  var $foreign = PS["Data.Traversable"];
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Category = PS["Control.Category"];
  var Data_Foldable = PS["Data.Foldable"];
  var Data_Functor = PS["Data.Functor"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_Maybe_First = PS["Data.Maybe.First"];
  var Data_Maybe_Last = PS["Data.Maybe.Last"];
  var Data_Monoid_Additive = PS["Data.Monoid.Additive"];
  var Data_Monoid_Conj = PS["Data.Monoid.Conj"];
  var Data_Monoid_Disj = PS["Data.Monoid.Disj"];
  var Data_Monoid_Dual = PS["Data.Monoid.Dual"];
  var Data_Monoid_Multiplicative = PS["Data.Monoid.Multiplicative"];
  var Data_Traversable_Accum = PS["Data.Traversable.Accum"];
  var Data_Traversable_Accum_Internal = PS["Data.Traversable.Accum.Internal"];
  var Prelude = PS["Prelude"];        
  var Traversable = function (Foldable1, Functor0, sequence, traverse) {
      this.Foldable1 = Foldable1;
      this.Functor0 = Functor0;
      this.sequence = sequence;
      this.traverse = traverse;
  };
  var traverse = function (dict) {
      return dict.traverse;
  }; 
  var sequenceDefault = function (dictTraversable) {
      return function (dictApplicative) {
          return traverse(dictTraversable)(dictApplicative)(Control_Category.id(Control_Category.categoryFn));
      };
  };
  var traversableArray = new Traversable(function () {
      return Data_Foldable.foldableArray;
  }, function () {
      return Data_Functor.functorArray;
  }, function (dictApplicative) {
      return sequenceDefault(traversableArray)(dictApplicative);
  }, function (dictApplicative) {
      return $foreign.traverseArrayImpl(Control_Apply.apply(dictApplicative.Apply0()))(Data_Functor.map((dictApplicative.Apply0()).Functor0()))(Control_Applicative.pure(dictApplicative));
  });
  var sequence = function (dict) {
      return dict.sequence;
  };
  exports["Traversable"] = Traversable;
  exports["sequence"] = sequence;
  exports["sequenceDefault"] = sequenceDefault;
  exports["traverse"] = traverse;
  exports["traversableArray"] = traversableArray;
})(PS["Data.Traversable"] = PS["Data.Traversable"] || {});
(function(exports) {
  // Generated by purs version 0.11.5
  "use strict";
  var Control_Alt = PS["Control.Alt"];
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Bind = PS["Control.Bind"];
  var Control_Extend = PS["Control.Extend"];
  var Control_Monad = PS["Control.Monad"];
  var Data_Bifoldable = PS["Data.Bifoldable"];
  var Data_Bifunctor = PS["Data.Bifunctor"];
  var Data_Bitraversable = PS["Data.Bitraversable"];
  var Data_Bounded = PS["Data.Bounded"];
  var Data_Eq = PS["Data.Eq"];
  var Data_Foldable = PS["Data.Foldable"];
  var Data_Function = PS["Data.Function"];
  var Data_Functor = PS["Data.Functor"];
  var Data_Functor_Invariant = PS["Data.Functor.Invariant"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_Monoid = PS["Data.Monoid"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Ordering = PS["Data.Ordering"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Semiring = PS["Data.Semiring"];
  var Data_Show = PS["Data.Show"];
  var Data_Traversable = PS["Data.Traversable"];
  var Prelude = PS["Prelude"];        
  var Left = (function () {
      function Left(value0) {
          this.value0 = value0;
      };
      Left.create = function (value0) {
          return new Left(value0);
      };
      return Left;
  })();
  var Right = (function () {
      function Right(value0) {
          this.value0 = value0;
      };
      Right.create = function (value0) {
          return new Right(value0);
      };
      return Right;
  })();
  var functorEither = new Data_Functor.Functor(function (v) {
      return function (v1) {
          if (v1 instanceof Left) {
              return new Left(v1.value0);
          };
          if (v1 instanceof Right) {
              return new Right(v(v1.value0));
          };
          throw new Error("Failed pattern match at Data.Either line 37, column 3 - line 37, column 26: " + [ v.constructor.name, v1.constructor.name ]);
      };
  });
  var either = function (v) {
      return function (v1) {
          return function (v2) {
              if (v2 instanceof Left) {
                  return v(v2.value0);
              };
              if (v2 instanceof Right) {
                  return v1(v2.value0);
              };
              throw new Error("Failed pattern match at Data.Either line 230, column 1 - line 230, column 26: " + [ v.constructor.name, v1.constructor.name, v2.constructor.name ]);
          };
      };
  };
  var bifunctorEither = new Data_Bifunctor.Bifunctor(function (v) {
      return function (v1) {
          return function (v2) {
              if (v2 instanceof Left) {
                  return new Left(v(v2.value0));
              };
              if (v2 instanceof Right) {
                  return new Right(v1(v2.value0));
              };
              throw new Error("Failed pattern match at Data.Either line 44, column 3 - line 44, column 34: " + [ v.constructor.name, v1.constructor.name, v2.constructor.name ]);
          };
      };
  });
  var applyEither = new Control_Apply.Apply(function () {
      return functorEither;
  }, function (v) {
      return function (v1) {
          if (v instanceof Left) {
              return new Left(v.value0);
          };
          if (v instanceof Right) {
              return Data_Functor.map(functorEither)(v.value0)(v1);
          };
          throw new Error("Failed pattern match at Data.Either line 80, column 3 - line 80, column 28: " + [ v.constructor.name, v1.constructor.name ]);
      };
  });
  var bindEither = new Control_Bind.Bind(function () {
      return applyEither;
  }, either(function (e) {
      return function (v) {
          return new Left(e);
      };
  })(function (a) {
      return function (f) {
          return f(a);
      };
  }));
  var applicativeEither = new Control_Applicative.Applicative(function () {
      return applyEither;
  }, Right.create);
  var altEither = new Control_Alt.Alt(function () {
      return functorEither;
  }, function (v) {
      return function (v1) {
          if (v instanceof Left) {
              return v1;
          };
          return v;
      };
  });
  exports["Left"] = Left;
  exports["Right"] = Right;
  exports["either"] = either;
  exports["functorEither"] = functorEither;
  exports["bifunctorEither"] = bifunctorEither;
  exports["applyEither"] = applyEither;
  exports["applicativeEither"] = applicativeEither;
  exports["altEither"] = altEither;
  exports["bindEither"] = bindEither;
})(PS["Data.Either"] = PS["Data.Either"] || {});
(function(exports) {
  // Generated by purs version 0.11.5
  "use strict";
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Bind = PS["Control.Bind"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Data_Either = PS["Data.Either"];
  var Data_Function = PS["Data.Function"];
  var Data_Functor = PS["Data.Functor"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_Unit = PS["Data.Unit"];
  var Prelude = PS["Prelude"];        
  var MonadThrow = function (Monad0, throwError) {
      this.Monad0 = Monad0;
      this.throwError = throwError;
  };
  var MonadError = function (MonadThrow0, catchError) {
      this.MonadThrow0 = MonadThrow0;
      this.catchError = catchError;
  };
  var throwError = function (dict) {
      return dict.throwError;
  }; 
  var catchError = function (dict) {
      return dict.catchError;
  };
  exports["MonadError"] = MonadError;
  exports["MonadThrow"] = MonadThrow;
  exports["catchError"] = catchError;
  exports["throwError"] = throwError;
})(PS["Control.Monad.Error.Class"] = PS["Control.Monad.Error.Class"] || {});
(function(exports) {
  // Generated by purs version 0.11.5
  "use strict";
  var Control_Category = PS["Control.Category"];
  var Control_Monad = PS["Control.Monad"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Data_Functor = PS["Data.Functor"];
  var Prelude = PS["Prelude"];        
  var MonadAsk = function (Monad0, ask) {
      this.Monad0 = Monad0;
      this.ask = ask;
  };
  var MonadReader = function (MonadAsk0, local) {
      this.MonadAsk0 = MonadAsk0;
      this.local = local;
  };                                                                           
  var local = function (dict) {
      return dict.local;
  };
  var ask = function (dict) {
      return dict.ask;
  };
  exports["MonadAsk"] = MonadAsk;
  exports["MonadReader"] = MonadReader;
  exports["ask"] = ask;
  exports["local"] = local;
})(PS["Control.Monad.Reader.Class"] = PS["Control.Monad.Reader.Class"] || {});
(function(exports) {
  // Generated by purs version 0.11.5
  "use strict";
  var Prelude = PS["Prelude"];        
  var MonadTrans = function (lift) {
      this.lift = lift;
  };
  var lift = function (dict) {
      return dict.lift;
  };
  exports["MonadTrans"] = MonadTrans;
  exports["lift"] = lift;
})(PS["Control.Monad.Trans.Class"] = PS["Control.Monad.Trans.Class"] || {});
(function(exports) {
  // Generated by purs version 0.11.5
  "use strict";
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Biapplicative = PS["Control.Biapplicative"];
  var Control_Biapply = PS["Control.Biapply"];
  var Control_Bind = PS["Control.Bind"];
  var Control_Comonad = PS["Control.Comonad"];
  var Control_Extend = PS["Control.Extend"];
  var Control_Lazy = PS["Control.Lazy"];
  var Control_Monad = PS["Control.Monad"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Data_Bifoldable = PS["Data.Bifoldable"];
  var Data_Bifunctor = PS["Data.Bifunctor"];
  var Data_Bitraversable = PS["Data.Bitraversable"];
  var Data_BooleanAlgebra = PS["Data.BooleanAlgebra"];
  var Data_Bounded = PS["Data.Bounded"];
  var Data_CommutativeRing = PS["Data.CommutativeRing"];
  var Data_Distributive = PS["Data.Distributive"];
  var Data_Eq = PS["Data.Eq"];
  var Data_Foldable = PS["Data.Foldable"];
  var Data_Function = PS["Data.Function"];
  var Data_Functor = PS["Data.Functor"];
  var Data_Functor_Invariant = PS["Data.Functor.Invariant"];
  var Data_HeytingAlgebra = PS["Data.HeytingAlgebra"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_Maybe_First = PS["Data.Maybe.First"];
  var Data_Monoid = PS["Data.Monoid"];
  var Data_Newtype = PS["Data.Newtype"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Ordering = PS["Data.Ordering"];
  var Data_Ring = PS["Data.Ring"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Semiring = PS["Data.Semiring"];
  var Data_Show = PS["Data.Show"];
  var Data_Traversable = PS["Data.Traversable"];
  var Data_Unit = PS["Data.Unit"];
  var Prelude = PS["Prelude"];
  var Type_Equality = PS["Type.Equality"];        
  var Tuple = (function () {
      function Tuple(value0, value1) {
          this.value0 = value0;
          this.value1 = value1;
      };
      Tuple.create = function (value0) {
          return function (value1) {
              return new Tuple(value0, value1);
          };
      };
      return Tuple;
  })();
  var uncurry = function (f) {
      return function (v) {
          return f(v.value0)(v.value1);
      };
  };
  var snd = function (v) {
      return v.value1;
  };
  var functorTuple = new Data_Functor.Functor(function (f) {
      return function (v) {
          return new Tuple(v.value0, f(v.value1));
      };
  });                                                                                                   
  var fst = function (v) {
      return v.value0;
  };
  var foldableTuple = new Data_Foldable.Foldable(function (dictMonoid) {
      return function (f) {
          return function (v) {
              return f(v.value1);
          };
      };
  }, function (f) {
      return function (z) {
          return function (v) {
              return f(z)(v.value1);
          };
      };
  }, function (f) {
      return function (z) {
          return function (v) {
              return f(v.value1)(z);
          };
      };
  });
  var traversableTuple = new Data_Traversable.Traversable(function () {
      return foldableTuple;
  }, function () {
      return functorTuple;
  }, function (dictApplicative) {
      return function (v) {
          return Data_Functor.map((dictApplicative.Apply0()).Functor0())(Tuple.create(v.value0))(v.value1);
      };
  }, function (dictApplicative) {
      return function (f) {
          return function (v) {
              return Data_Functor.map((dictApplicative.Apply0()).Functor0())(Tuple.create(v.value0))(f(v.value1));
          };
      };
  });
  exports["Tuple"] = Tuple;
  exports["fst"] = fst;
  exports["snd"] = snd;
  exports["uncurry"] = uncurry;
  exports["functorTuple"] = functorTuple;
  exports["foldableTuple"] = foldableTuple;
  exports["traversableTuple"] = traversableTuple;
})(PS["Data.Tuple"] = PS["Data.Tuple"] || {});
(function(exports) {
  // Generated by purs version 0.11.5
  "use strict";
  var Control_Alt = PS["Control.Alt"];
  var Control_Alternative = PS["Control.Alternative"];
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Bind = PS["Control.Bind"];
  var Control_Category = PS["Control.Category"];
  var Control_Monad = PS["Control.Monad"];
  var Control_Monad_Cont_Class = PS["Control.Monad.Cont.Class"];
  var Control_Monad_Eff_Class = PS["Control.Monad.Eff.Class"];
  var Control_Monad_Error_Class = PS["Control.Monad.Error.Class"];
  var Control_Monad_Reader_Class = PS["Control.Monad.Reader.Class"];
  var Control_Monad_Rec_Class = PS["Control.Monad.Rec.Class"];
  var Control_Monad_State_Class = PS["Control.Monad.State.Class"];
  var Control_Monad_Trans_Class = PS["Control.Monad.Trans.Class"];
  var Control_Monad_Writer_Class = PS["Control.Monad.Writer.Class"];
  var Control_MonadPlus = PS["Control.MonadPlus"];
  var Control_MonadZero = PS["Control.MonadZero"];
  var Control_Plus = PS["Control.Plus"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Data_Either = PS["Data.Either"];
  var Data_Function = PS["Data.Function"];
  var Data_Functor = PS["Data.Functor"];
  var Data_Monoid = PS["Data.Monoid"];
  var Data_Newtype = PS["Data.Newtype"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Tuple = PS["Data.Tuple"];
  var Prelude = PS["Prelude"];        
  var ExceptT = function (x) {
      return x;
  };
  var runExceptT = function (v) {
      return v;
  };          
  var monadTransExceptT = new Control_Monad_Trans_Class.MonadTrans(function (dictMonad) {
      return function (m) {
          return Control_Bind.bind(dictMonad.Bind1())(m)(function (v) {
              return Control_Applicative.pure(dictMonad.Applicative0())(new Data_Either.Right(v));
          });
      };
  });
  var mapExceptT = function (f) {
      return function (v) {
          return f(v);
      };
  };
  var functorExceptT = function (dictFunctor) {
      return new Data_Functor.Functor(function (f) {
          return mapExceptT(Data_Functor.map(dictFunctor)(Data_Functor.map(Data_Either.functorEither)(f)));
      });
  };
  var except = function (dictApplicative) {
      return function ($96) {
          return ExceptT(Control_Applicative.pure(dictApplicative)($96));
      };
  };
  var monadExceptT = function (dictMonad) {
      return new Control_Monad.Monad(function () {
          return applicativeExceptT(dictMonad);
      }, function () {
          return bindExceptT(dictMonad);
      });
  };
  var bindExceptT = function (dictMonad) {
      return new Control_Bind.Bind(function () {
          return applyExceptT(dictMonad);
      }, function (v) {
          return function (k) {
              return Control_Bind.bind(dictMonad.Bind1())(v)(Data_Either.either(function ($97) {
                  return Control_Applicative.pure(dictMonad.Applicative0())(Data_Either.Left.create($97));
              })(function (a) {
                  var v1 = k(a);
                  return v1;
              }));
          };
      });
  };
  var applyExceptT = function (dictMonad) {
      return new Control_Apply.Apply(function () {
          return functorExceptT(((dictMonad.Bind1()).Apply0()).Functor0());
      }, Control_Monad.ap(monadExceptT(dictMonad)));
  };
  var applicativeExceptT = function (dictMonad) {
      return new Control_Applicative.Applicative(function () {
          return applyExceptT(dictMonad);
      }, function ($98) {
          return ExceptT(Control_Applicative.pure(dictMonad.Applicative0())(Data_Either.Right.create($98)));
      });
  };
  var monadEffExceptT = function (dictMonadEff) {
      return new Control_Monad_Eff_Class.MonadEff(function () {
          return monadExceptT(dictMonadEff.Monad0());
      }, function ($99) {
          return Control_Monad_Trans_Class.lift(monadTransExceptT)(dictMonadEff.Monad0())(Control_Monad_Eff_Class.liftEff(dictMonadEff)($99));
      });
  };
  var monadThrowExceptT = function (dictMonad) {
      return new Control_Monad_Error_Class.MonadThrow(function () {
          return monadExceptT(dictMonad);
      }, function ($102) {
          return ExceptT(Control_Applicative.pure(dictMonad.Applicative0())(Data_Either.Left.create($102)));
      });
  };
  var monadErrorExceptT = function (dictMonad) {
      return new Control_Monad_Error_Class.MonadError(function () {
          return monadThrowExceptT(dictMonad);
      }, function (v) {
          return function (k) {
              return Control_Bind.bind(dictMonad.Bind1())(v)(Data_Either.either(function (a) {
                  var v1 = k(a);
                  return v1;
              })(function ($103) {
                  return Control_Applicative.pure(dictMonad.Applicative0())(Data_Either.Right.create($103));
              }));
          };
      });
  };
  exports["ExceptT"] = ExceptT;
  exports["except"] = except;
  exports["mapExceptT"] = mapExceptT;
  exports["runExceptT"] = runExceptT;
  exports["functorExceptT"] = functorExceptT;
  exports["applyExceptT"] = applyExceptT;
  exports["applicativeExceptT"] = applicativeExceptT;
  exports["bindExceptT"] = bindExceptT;
  exports["monadExceptT"] = monadExceptT;
  exports["monadTransExceptT"] = monadTransExceptT;
  exports["monadEffExceptT"] = monadEffExceptT;
  exports["monadThrowExceptT"] = monadThrowExceptT;
  exports["monadErrorExceptT"] = monadErrorExceptT;
})(PS["Control.Monad.Except.Trans"] = PS["Control.Monad.Except.Trans"] || {});
(function(exports) {
  // Generated by purs version 0.11.5
  "use strict";
  var Control_Alt = PS["Control.Alt"];
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Bind = PS["Control.Bind"];
  var Control_Comonad = PS["Control.Comonad"];
  var Control_Extend = PS["Control.Extend"];
  var Control_Lazy = PS["Control.Lazy"];
  var Control_Monad = PS["Control.Monad"];
  var Data_BooleanAlgebra = PS["Data.BooleanAlgebra"];
  var Data_Bounded = PS["Data.Bounded"];
  var Data_CommutativeRing = PS["Data.CommutativeRing"];
  var Data_Eq = PS["Data.Eq"];
  var Data_EuclideanRing = PS["Data.EuclideanRing"];
  var Data_Field = PS["Data.Field"];
  var Data_Foldable = PS["Data.Foldable"];
  var Data_Functor = PS["Data.Functor"];
  var Data_Functor_Invariant = PS["Data.Functor.Invariant"];
  var Data_HeytingAlgebra = PS["Data.HeytingAlgebra"];
  var Data_Monoid = PS["Data.Monoid"];
  var Data_Newtype = PS["Data.Newtype"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Ring = PS["Data.Ring"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Semiring = PS["Data.Semiring"];
  var Data_Show = PS["Data.Show"];
  var Data_Traversable = PS["Data.Traversable"];
  var Prelude = PS["Prelude"];        
  var Identity = function (x) {
      return x;
  };
  var newtypeIdentity = new Data_Newtype.Newtype(function (n) {
      return n;
  }, Identity);
  var functorIdentity = new Data_Functor.Functor(function (f) {
      return function (v) {
          return f(v);
      };
  });
  var applyIdentity = new Control_Apply.Apply(function () {
      return functorIdentity;
  }, function (v) {
      return function (v1) {
          return v(v1);
      };
  });
  var applicativeIdentity = new Control_Applicative.Applicative(function () {
      return applyIdentity;
  }, Identity);
  exports["Identity"] = Identity;
  exports["newtypeIdentity"] = newtypeIdentity;
  exports["functorIdentity"] = functorIdentity;
  exports["applyIdentity"] = applyIdentity;
  exports["applicativeIdentity"] = applicativeIdentity;
})(PS["Data.Identity"] = PS["Data.Identity"] || {});
(function(exports) {
  // Generated by purs version 0.11.5
  "use strict";
  var Control_Monad_Error_Class = PS["Control.Monad.Error.Class"];
  var Control_Monad_Except_Trans = PS["Control.Monad.Except.Trans"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Data_Either = PS["Data.Either"];
  var Data_Identity = PS["Data.Identity"];
  var Data_Newtype = PS["Data.Newtype"];
  var Prelude = PS["Prelude"];                                                           
  var runExcept = function ($0) {
      return Data_Newtype.unwrap(Data_Identity.newtypeIdentity)(Control_Monad_Except_Trans.runExceptT($0));
  };
  exports["runExcept"] = runExcept;
})(PS["Control.Monad.Except"] = PS["Control.Monad.Except"] || {});
(function(exports) {
  // Generated by purs version 0.11.5
  "use strict";
  var Control_Alt = PS["Control.Alt"];
  var Control_Alternative = PS["Control.Alternative"];
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Bind = PS["Control.Bind"];
  var Control_Monad = PS["Control.Monad"];
  var Control_Monad_Cont_Class = PS["Control.Monad.Cont.Class"];
  var Control_Monad_Eff_Class = PS["Control.Monad.Eff.Class"];
  var Control_Monad_Error_Class = PS["Control.Monad.Error.Class"];
  var Control_Monad_Reader_Class = PS["Control.Monad.Reader.Class"];
  var Control_Monad_Rec_Class = PS["Control.Monad.Rec.Class"];
  var Control_Monad_State_Class = PS["Control.Monad.State.Class"];
  var Control_Monad_Trans_Class = PS["Control.Monad.Trans.Class"];
  var Control_Monad_Writer_Class = PS["Control.Monad.Writer.Class"];
  var Control_MonadPlus = PS["Control.MonadPlus"];
  var Control_MonadZero = PS["Control.MonadZero"];
  var Control_Plus = PS["Control.Plus"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Data_Distributive = PS["Data.Distributive"];
  var Data_Function = PS["Data.Function"];
  var Data_Functor = PS["Data.Functor"];
  var Data_Monoid = PS["Data.Monoid"];
  var Data_Newtype = PS["Data.Newtype"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Prelude = PS["Prelude"];        
  var ReaderT = function (x) {
      return x;
  };
  var withReaderT = function (f) {
      return function (v) {
          return function ($66) {
              return v(f($66));
          };
      };
  };
  var runReaderT = function (v) {
      return v;
  };          
  var monadTransReaderT = new Control_Monad_Trans_Class.MonadTrans(function (dictMonad) {
      return function ($67) {
          return ReaderT(Data_Function["const"]($67));
      };
  });
  var mapReaderT = function (f) {
      return function (v) {
          return function ($68) {
              return f(v($68));
          };
      };
  };
  var functorReaderT = function (dictFunctor) {
      return new Data_Functor.Functor(function ($69) {
          return mapReaderT(Data_Functor.map(dictFunctor)($69));
      });
  };
  var applyReaderT = function (dictApply) {
      return new Control_Apply.Apply(function () {
          return functorReaderT(dictApply.Functor0());
      }, function (v) {
          return function (v1) {
              return function (r) {
                  return Control_Apply.apply(dictApply)(v(r))(v1(r));
              };
          };
      });
  };
  var bindReaderT = function (dictBind) {
      return new Control_Bind.Bind(function () {
          return applyReaderT(dictBind.Apply0());
      }, function (v) {
          return function (k) {
              return function (r) {
                  return Control_Bind.bind(dictBind)(v(r))(function (a) {
                      var v1 = k(a);
                      return v1(r);
                  });
              };
          };
      });
  };
  var applicativeReaderT = function (dictApplicative) {
      return new Control_Applicative.Applicative(function () {
          return applyReaderT(dictApplicative.Apply0());
      }, function ($71) {
          return ReaderT(Data_Function["const"](Control_Applicative.pure(dictApplicative)($71)));
      });
  };
  var monadReaderT = function (dictMonad) {
      return new Control_Monad.Monad(function () {
          return applicativeReaderT(dictMonad.Applicative0());
      }, function () {
          return bindReaderT(dictMonad.Bind1());
      });
  };
  var monadAskReaderT = function (dictMonad) {
      return new Control_Monad_Reader_Class.MonadAsk(function () {
          return monadReaderT(dictMonad);
      }, Control_Applicative.pure(dictMonad.Applicative0()));
  };
  var monadReaderReaderT = function (dictMonad) {
      return new Control_Monad_Reader_Class.MonadReader(function () {
          return monadAskReaderT(dictMonad);
      }, withReaderT);
  };
  var monadEffReader = function (dictMonadEff) {
      return new Control_Monad_Eff_Class.MonadEff(function () {
          return monadReaderT(dictMonadEff.Monad0());
      }, function ($73) {
          return Control_Monad_Trans_Class.lift(monadTransReaderT)(dictMonadEff.Monad0())(Control_Monad_Eff_Class.liftEff(dictMonadEff)($73));
      });
  };
  exports["ReaderT"] = ReaderT;
  exports["mapReaderT"] = mapReaderT;
  exports["runReaderT"] = runReaderT;
  exports["withReaderT"] = withReaderT;
  exports["functorReaderT"] = functorReaderT;
  exports["applyReaderT"] = applyReaderT;
  exports["applicativeReaderT"] = applicativeReaderT;
  exports["bindReaderT"] = bindReaderT;
  exports["monadReaderT"] = monadReaderT;
  exports["monadTransReaderT"] = monadTransReaderT;
  exports["monadEffReader"] = monadEffReader;
  exports["monadAskReaderT"] = monadAskReaderT;
  exports["monadReaderReaderT"] = monadReaderReaderT;
})(PS["Control.Monad.Reader.Trans"] = PS["Control.Monad.Reader.Trans"] || {});
(function(exports) {
    "use strict";

  // module Data.Int

  exports.fromNumberImpl = function (just) {
    return function (nothing) {
      return function (n) {
        /* jshint bitwise: false */
        return (n | 0) === n ? just(n) : nothing;
      };
    };
  };

  exports.toNumber = function (n) {
    return n;
  };
})(PS["Data.Int"] = PS["Data.Int"] || {});
(function(exports) {
    "use strict";

  exports.pow = function (n) {
    return function (p) {
      return Math.pow(n, p);
    };
  };                           

  exports.pi = Math.PI;
})(PS["Math"] = PS["Math"] || {});
(function(exports) {
  // Generated by purs version 0.11.5
  "use strict";
  var $foreign = PS["Math"];
  exports["pi"] = $foreign.pi;
  exports["pow"] = $foreign.pow;
})(PS["Math"] = PS["Math"] || {});
(function(exports) {
  // Generated by purs version 0.11.5
  "use strict";
  var $foreign = PS["Data.Int"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Data_Boolean = PS["Data.Boolean"];
  var Data_Bounded = PS["Data.Bounded"];
  var Data_Eq = PS["Data.Eq"];
  var Data_HeytingAlgebra = PS["Data.HeytingAlgebra"];
  var Data_Int_Bits = PS["Data.Int.Bits"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Ordering = PS["Data.Ordering"];
  var Data_Ring = PS["Data.Ring"];
  var Data_Show = PS["Data.Show"];
  var Global = PS["Global"];
  var $$Math = PS["Math"];
  var Prelude = PS["Prelude"];      
  var fromNumber = $foreign.fromNumberImpl(Data_Maybe.Just.create)(Data_Maybe.Nothing.value);
  exports["fromNumber"] = fromNumber;
  exports["toNumber"] = $foreign.toNumber;
})(PS["Data.Int"] = PS["Data.Int"] || {});
(function(exports) {
  // Generated by purs version 0.11.5
  "use strict";
  var $foreign = PS["Data.Foreign"];
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Monad_Error_Class = PS["Control.Monad.Error.Class"];
  var Control_Monad_Except = PS["Control.Monad.Except"];
  var Control_Monad_Except_Trans = PS["Control.Monad.Except.Trans"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Data_Boolean = PS["Data.Boolean"];
  var Data_Either = PS["Data.Either"];
  var Data_Eq = PS["Data.Eq"];
  var Data_Function = PS["Data.Function"];
  var Data_HeytingAlgebra = PS["Data.HeytingAlgebra"];
  var Data_Identity = PS["Data.Identity"];
  var Data_Int = PS["Data.Int"];
  var Data_List_NonEmpty = PS["Data.List.NonEmpty"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Ordering = PS["Data.Ordering"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Show = PS["Data.Show"];
  var Data_String = PS["Data.String"];
  var Prelude = PS["Prelude"];
  var TypeMismatch = (function () {
      function TypeMismatch(value0, value1) {
          this.value0 = value0;
          this.value1 = value1;
      };
      TypeMismatch.create = function (value0) {
          return function (value1) {
              return new TypeMismatch(value0, value1);
          };
      };
      return TypeMismatch;
  })();
  exports["TypeMismatch"] = TypeMismatch;
})(PS["Data.Foreign"] = PS["Data.Foreign"] || {});
(function(exports) {
    "use strict";

  // module Unsafe.Coerce

  exports.unsafeCoerce = function (x) {
    return x;
  };
})(PS["Unsafe.Coerce"] = PS["Unsafe.Coerce"] || {});
(function(exports) {
  // Generated by purs version 0.11.5
  "use strict";
  var $foreign = PS["Unsafe.Coerce"];
  exports["unsafeCoerce"] = $foreign.unsafeCoerce;
})(PS["Unsafe.Coerce"] = PS["Unsafe.Coerce"] || {});
(function(exports) {
  // Generated by purs version 0.11.5
  "use strict";
  var Control_Monad_Except = PS["Control.Monad.Except"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Data_Either = PS["Data.Either"];
  var Data_Foreign = PS["Data.Foreign"];
  var Data_Function = PS["Data.Function"];
  var Data_Maybe = PS["Data.Maybe"];
  var Prelude = PS["Prelude"];
  var Unsafe_Coerce = PS["Unsafe.Coerce"];        
  var fromAny = function (f) {
      return function ($0) {
          return Data_Either.either(Data_Function["const"](Data_Maybe.Nothing.value))(Data_Maybe.Just.create)(Control_Monad_Except.runExcept(Unsafe_Coerce.unsafeCoerce(f)($0)));
      };
  };
  exports["fromAny"] = fromAny;
})(PS["DOM.Classy.Util"] = PS["DOM.Classy.Util"] || {});
(function(exports) {
    "use strict";

  exports._unsafeReadProtoTagged = function (name) {
    return function (failure) {
      return function (success) {
        return function (value) {
          var obj = value;
          while (obj != null) {
            var proto = Object.getPrototypeOf(obj);
            var ctor = proto.constructor.name;
            if (ctor === name) {
              return success(value);
            } else if (ctor === "Object") {
              return failure(Object.getPrototypeOf(value).constructor.name);
            }
            obj = proto;
          }
          return failure(Object.getPrototypeOf(value).constructor.name);
        };
      };
    };
  };
})(PS["DOM.Util.FFI"] = PS["DOM.Util.FFI"] || {});
(function(exports) {
  // Generated by purs version 0.11.5
  "use strict";
  var Control_Alt = PS["Control.Alt"];
  var Control_Alternative = PS["Control.Alternative"];
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Category = PS["Control.Category"];
  var Control_Plus = PS["Control.Plus"];
  var Data_Eq = PS["Data.Eq"];
  var Data_Foldable = PS["Data.Foldable"];
  var Data_Functor = PS["Data.Functor"];
  var Data_HeytingAlgebra = PS["Data.HeytingAlgebra"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Ordering = PS["Data.Ordering"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Show = PS["Data.Show"];
  var Data_Traversable = PS["Data.Traversable"];
  var Prelude = PS["Prelude"];        
  var NonEmpty = (function () {
      function NonEmpty(value0, value1) {
          this.value0 = value0;
          this.value1 = value1;
      };
      NonEmpty.create = function (value0) {
          return function (value1) {
              return new NonEmpty(value0, value1);
          };
      };
      return NonEmpty;
  })();
  var singleton = function (dictPlus) {
      return function (a) {
          return new NonEmpty(a, Control_Plus.empty(dictPlus));
      };
  };
  var functorNonEmpty = function (dictFunctor) {
      return new Data_Functor.Functor(function (f) {
          return function (v) {
              return new NonEmpty(f(v.value0), Data_Functor.map(dictFunctor)(f)(v.value1));
          };
      });
  };
  exports["NonEmpty"] = NonEmpty;
  exports["singleton"] = singleton;
  exports["functorNonEmpty"] = functorNonEmpty;
})(PS["Data.NonEmpty"] = PS["Data.NonEmpty"] || {});
(function(exports) {
    "use strict";

  exports.unfoldrArrayImpl = function (isNothing) {
    return function (fromJust) {
      return function (fst) {
        return function (snd) {
          return function (f) {
            return function (b) {
              var result = [];
              var value = b;
              while (true) { // eslint-disable-line no-constant-condition
                var maybe = f(value);
                if (isNothing(maybe)) return result;
                var tuple = fromJust(maybe);
                result.push(fst(tuple));
                value = snd(tuple);
              }
            };
          };
        };
      };
    };
  };
})(PS["Data.Unfoldable"] = PS["Data.Unfoldable"] || {});
(function(exports) {
  // Generated by purs version 0.11.5
  "use strict";
  var $foreign = PS["Data.Unfoldable"];
  var Data_Function = PS["Data.Function"];
  var Data_Functor = PS["Data.Functor"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Ring = PS["Data.Ring"];
  var Data_Traversable = PS["Data.Traversable"];
  var Data_Tuple = PS["Data.Tuple"];
  var Data_Unit = PS["Data.Unit"];
  var Partial_Unsafe = PS["Partial.Unsafe"];
  var Prelude = PS["Prelude"];        
  var Unfoldable = function (unfoldr) {
      this.unfoldr = unfoldr;
  };
  var unfoldr = function (dict) {
      return dict.unfoldr;
  };
  var unfoldableArray = new Unfoldable($foreign.unfoldrArrayImpl(Data_Maybe.isNothing)(Data_Maybe.fromJust())(Data_Tuple.fst)(Data_Tuple.snd));
  exports["Unfoldable"] = Unfoldable;
  exports["unfoldr"] = unfoldr;
  exports["unfoldableArray"] = unfoldableArray;
})(PS["Data.Unfoldable"] = PS["Data.Unfoldable"] || {});
(function(exports) {
  // Generated by purs version 0.11.5
  "use strict";
  var Control_Alt = PS["Control.Alt"];
  var Control_Alternative = PS["Control.Alternative"];
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Bind = PS["Control.Bind"];
  var Control_Category = PS["Control.Category"];
  var Control_Comonad = PS["Control.Comonad"];
  var Control_Extend = PS["Control.Extend"];
  var Control_Monad = PS["Control.Monad"];
  var Control_MonadPlus = PS["Control.MonadPlus"];
  var Control_MonadZero = PS["Control.MonadZero"];
  var Control_Plus = PS["Control.Plus"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Data_Eq = PS["Data.Eq"];
  var Data_Foldable = PS["Data.Foldable"];
  var Data_Function = PS["Data.Function"];
  var Data_Functor = PS["Data.Functor"];
  var Data_HeytingAlgebra = PS["Data.HeytingAlgebra"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_Monoid = PS["Data.Monoid"];
  var Data_Newtype = PS["Data.Newtype"];
  var Data_NonEmpty = PS["Data.NonEmpty"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Ordering = PS["Data.Ordering"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Semigroup_Foldable = PS["Data.Semigroup.Foldable"];
  var Data_Semigroup_Traversable = PS["Data.Semigroup.Traversable"];
  var Data_Show = PS["Data.Show"];
  var Data_Traversable = PS["Data.Traversable"];
  var Data_Tuple = PS["Data.Tuple"];
  var Data_Unfoldable = PS["Data.Unfoldable"];
  var Prelude = PS["Prelude"];        
  var Nil = (function () {
      function Nil() {

      };
      Nil.value = new Nil();
      return Nil;
  })();
  var Cons = (function () {
      function Cons(value0, value1) {
          this.value0 = value0;
          this.value1 = value1;
      };
      Cons.create = function (value0) {
          return function (value1) {
              return new Cons(value0, value1);
          };
      };
      return Cons;
  })();
  var NonEmptyList = function (x) {
      return x;
  };
  var foldableList = new Data_Foldable.Foldable(function (dictMonoid) {
      return function (f) {
          return Data_Foldable.foldl(foldableList)(function (acc) {
              return function ($143) {
                  return Data_Semigroup.append(dictMonoid.Semigroup0())(acc)(f($143));
              };
          })(Data_Monoid.mempty(dictMonoid));
      };
  }, function (f) {
      var go = function ($copy_b) {
          return function ($copy_v) {
              var $tco_var_b = $copy_b;
              var $tco_done = false;
              var $tco_result;
              function $tco_loop(b, v) {
                  if (v instanceof Nil) {
                      $tco_done = true;
                      return b;
                  };
                  if (v instanceof Cons) {
                      $tco_var_b = f(b)(v.value0);
                      $copy_v = v.value1;
                      return;
                  };
                  throw new Error("Failed pattern match at Data.List.Types line 78, column 12 - line 80, column 30: " + [ v.constructor.name ]);
              };
              while (!$tco_done) {
                  $tco_result = $tco_loop($tco_var_b, $copy_v);
              };
              return $tco_result;
          };
      };
      return go;
  }, function (f) {
      return function (b) {
          var rev = function ($copy_acc) {
              return function ($copy_v) {
                  var $tco_var_acc = $copy_acc;
                  var $tco_done = false;
                  var $tco_result;
                  function $tco_loop(acc, v) {
                      if (v instanceof Nil) {
                          $tco_done = true;
                          return acc;
                      };
                      if (v instanceof Cons) {
                          $tco_var_acc = new Cons(v.value0, acc);
                          $copy_v = v.value1;
                          return;
                      };
                      throw new Error("Failed pattern match at Data.List.Types line 73, column 15 - line 75, column 33: " + [ v.constructor.name ]);
                  };
                  while (!$tco_done) {
                      $tco_result = $tco_loop($tco_var_acc, $copy_v);
                  };
                  return $tco_result;
              };
          };
          return function ($144) {
              return Data_Foldable.foldl(foldableList)(Data_Function.flip(f))(b)(rev(Nil.value)($144));
          };
      };
  });                                                                     
  var functorList = new Data_Functor.Functor(function (f) {
      return Data_Foldable.foldr(foldableList)(function (x) {
          return function (acc) {
              return new Cons(f(x), acc);
          };
      })(Nil.value);
  });
  var functorNonEmptyList = Data_NonEmpty.functorNonEmpty(functorList);
  var semigroupList = new Data_Semigroup.Semigroup(function (xs) {
      return function (ys) {
          return Data_Foldable.foldr(foldableList)(Cons.create)(ys)(xs);
      };
  });
  var traversableList = new Data_Traversable.Traversable(function () {
      return foldableList;
  }, function () {
      return functorList;
  }, function (dictApplicative) {
      return Data_Traversable.traverse(traversableList)(dictApplicative)(Control_Category.id(Control_Category.categoryFn));
  }, function (dictApplicative) {
      return function (f) {
          return function ($145) {
              return Data_Functor.map((dictApplicative.Apply0()).Functor0())(Data_Foldable.foldl(foldableList)(Data_Function.flip(Cons.create))(Nil.value))(Data_Foldable.foldl(foldableList)(function (acc) {
                  return function ($146) {
                      return Control_Apply.lift2(dictApplicative.Apply0())(Data_Function.flip(Cons.create))(acc)(f($146));
                  };
              })(Control_Applicative.pure(dictApplicative)(Nil.value))($145));
          };
      };
  });
  var applyList = new Control_Apply.Apply(function () {
      return functorList;
  }, function (v) {
      return function (v1) {
          if (v instanceof Nil) {
              return Nil.value;
          };
          if (v instanceof Cons) {
              return Data_Semigroup.append(semigroupList)(Data_Functor.map(functorList)(v.value0)(v1))(Control_Apply.apply(applyList)(v.value1)(v1));
          };
          throw new Error("Failed pattern match at Data.List.Types line 95, column 3 - line 95, column 20: " + [ v.constructor.name, v1.constructor.name ]);
      };
  });
  var applyNonEmptyList = new Control_Apply.Apply(function () {
      return functorNonEmptyList;
  }, function (v) {
      return function (v1) {
          return new Data_NonEmpty.NonEmpty(v.value0(v1.value0), Data_Semigroup.append(semigroupList)(Control_Apply.apply(applyList)(v.value1)(new Cons(v1.value0, Nil.value)))(Control_Apply.apply(applyList)(new Cons(v.value0, v.value1))(v1.value1)));
      };
  });                                              
  var altList = new Control_Alt.Alt(function () {
      return functorList;
  }, Data_Semigroup.append(semigroupList));
  var plusList = new Control_Plus.Plus(function () {
      return altList;
  }, Nil.value);
  var applicativeNonEmptyList = new Control_Applicative.Applicative(function () {
      return applyNonEmptyList;
  }, function ($149) {
      return NonEmptyList(Data_NonEmpty.singleton(plusList)($149));
  });
  exports["Nil"] = Nil;
  exports["Cons"] = Cons;
  exports["NonEmptyList"] = NonEmptyList;
  exports["semigroupList"] = semigroupList;
  exports["functorList"] = functorList;
  exports["foldableList"] = foldableList;
  exports["traversableList"] = traversableList;
  exports["applyList"] = applyList;
  exports["altList"] = altList;
  exports["plusList"] = plusList;
  exports["functorNonEmptyList"] = functorNonEmptyList;
  exports["applyNonEmptyList"] = applyNonEmptyList;
  exports["applicativeNonEmptyList"] = applicativeNonEmptyList;
})(PS["Data.List.Types"] = PS["Data.List.Types"] || {});
(function(exports) {
  // Generated by purs version 0.11.5
  "use strict";
  var $foreign = PS["DOM.Util.FFI"];
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Monad_Except = PS["Control.Monad.Except"];
  var Control_Monad_Except_Trans = PS["Control.Monad.Except.Trans"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Data_Either = PS["Data.Either"];
  var Data_Foreign = PS["Data.Foreign"];
  var Data_Identity = PS["Data.Identity"];
  var Data_List_Types = PS["Data.List.Types"];
  var Prelude = PS["Prelude"];        
  var unsafeReadProtoTagged = function (name) {
      return $foreign._unsafeReadProtoTagged(name)(function ($0) {
          return Control_Monad_Except_Trans.except(Data_Identity.applicativeIdentity)(Data_Either.Left.create(Control_Applicative.pure(Data_List_Types.applicativeNonEmptyList)(Data_Foreign.TypeMismatch.create(name)($0))));
      })(function ($1) {
          return Control_Monad_Except_Trans.except(Data_Identity.applicativeIdentity)(Data_Either.Right.create($1));
      });
  };
  exports["unsafeReadProtoTagged"] = unsafeReadProtoTagged;
})(PS["DOM.Util.FFI"] = PS["DOM.Util.FFI"] || {});
(function(exports) {
  // Generated by purs version 0.11.5
  "use strict";
  var DOM_Event_Types = PS["DOM.Event.Types"];
  var DOM_Util_FFI = PS["DOM.Util.FFI"];
  var Data_Eq = PS["Data.Eq"];
  var Data_Foreign = PS["Data.Foreign"];
  var Data_Newtype = PS["Data.Newtype"];
  var Data_Ord = PS["Data.Ord"];
  var Prelude = PS["Prelude"];
  var Unsafe_Coerce = PS["Unsafe.Coerce"];                  
  var readElement = DOM_Util_FFI.unsafeReadProtoTagged("Element");
  var readDocument = DOM_Util_FFI.unsafeReadProtoTagged("Document");
  exports["readDocument"] = readDocument;
  exports["readElement"] = readElement;
})(PS["DOM.Node.Types"] = PS["DOM.Node.Types"] || {});
(function(exports) {
  // Generated by purs version 0.11.5
  "use strict";
  var $foreign = PS["DOM.HTML.Types"];
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Monad_Eff = PS["Control.Monad.Eff"];
  var Control_Monad_Except_Trans = PS["Control.Monad.Except.Trans"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var DOM_Event_Types = PS["DOM.Event.Types"];
  var DOM_Node_Types = PS["DOM.Node.Types"];
  var Data_Either = PS["Data.Either"];
  var Data_Foreign = PS["Data.Foreign"];
  var Data_Identity = PS["Data.Identity"];
  var Data_List_Types = PS["Data.List.Types"];
  var Prelude = PS["Prelude"];
  var Unsafe_Coerce = PS["Unsafe.Coerce"];                   
  var htmlDocumentToDocument = Unsafe_Coerce.unsafeCoerce;
  exports["htmlDocumentToDocument"] = htmlDocumentToDocument;
})(PS["DOM.HTML.Types"] = PS["DOM.HTML.Types"] || {});
(function(exports) {
  // Generated by purs version 0.11.5
  "use strict";
  var Control_Monad_Eff = PS["Control.Monad.Eff"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var DOM = PS["DOM"];
  var DOM_Classy_Util = PS["DOM.Classy.Util"];
  var DOM_HTML_Types = PS["DOM.HTML.Types"];
  var DOM_Node_Node = PS["DOM.Node.Node"];
  var DOM_Node_NodeType = PS["DOM.Node.NodeType"];
  var DOM_Node_Types = PS["DOM.Node.Types"];
  var Data_Maybe = PS["Data.Maybe"];
  var Prelude = PS["Prelude"];
  var Unsafe_Coerce = PS["Unsafe.Coerce"];        
  var IsNode = function (fromNode, toNode) {
      this.fromNode = fromNode;
      this.toNode = toNode;
  };
  var toNode = function (dict) {
      return dict.toNode;
  };                                                                                                                                  
  var isNodeElement = new IsNode(DOM_Classy_Util.fromAny(DOM_Node_Types.readElement), Unsafe_Coerce.unsafeCoerce);
  var fromNode = function (dict) {
      return dict.fromNode;
  };
  exports["IsNode"] = IsNode;
  exports["fromNode"] = fromNode;
  exports["toNode"] = toNode;
  exports["isNodeElement"] = isNodeElement;
})(PS["DOM.Classy.Node"] = PS["DOM.Classy.Node"] || {});
(function(exports) {
    "use strict";                                             

  exports._querySelector = function (selector) {
    return function (node) {
      return function () {
        return node.querySelector(selector);
      };
    };
  };

  exports.querySelectorAll = function (selector) {
    return function (node) {
      return function () {
        return node.querySelectorAll(selector);
      };
    };
  };
})(PS["DOM.Node.ParentNode"] = PS["DOM.Node.ParentNode"] || {});
(function(exports) {
    "use strict";        

  exports.nullable = function (a, r, f) {
    return a == null ? r : f(a);
  };
})(PS["Data.Nullable"] = PS["Data.Nullable"] || {});
(function(exports) {
    "use strict";

  exports.runFn4 = function (fn) {
    return function (a) {
      return function (b) {
        return function (c) {
          return function (d) {
            return fn(a, b, c, d);
          };
        };
      };
    };
  };
})(PS["Data.Function.Uncurried"] = PS["Data.Function.Uncurried"] || {});
(function(exports) {
  // Generated by purs version 0.11.5
  "use strict";
  var $foreign = PS["Data.Function.Uncurried"];
  var Data_Unit = PS["Data.Unit"];
  exports["runFn4"] = $foreign.runFn4;
})(PS["Data.Function.Uncurried"] = PS["Data.Function.Uncurried"] || {});
(function(exports) {
  // Generated by purs version 0.11.5
  "use strict";
  var $foreign = PS["Data.Nullable"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Data_Eq = PS["Data.Eq"];
  var Data_Function = PS["Data.Function"];
  var Data_Function_Uncurried = PS["Data.Function.Uncurried"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Show = PS["Data.Show"];
  var Prelude = PS["Prelude"];                                          
  var toMaybe = function (n) {
      return $foreign.nullable(n, Data_Maybe.Nothing.value, Data_Maybe.Just.create);
  };
  exports["toMaybe"] = toMaybe;
})(PS["Data.Nullable"] = PS["Data.Nullable"] || {});
(function(exports) {
  // Generated by purs version 0.11.5
  "use strict";
  var $foreign = PS["DOM.Node.ParentNode"];
  var Control_Monad_Eff = PS["Control.Monad.Eff"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var DOM = PS["DOM"];
  var DOM_Node_Types = PS["DOM.Node.Types"];
  var Data_Eq = PS["Data.Eq"];
  var Data_Functor = PS["Data.Functor"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_Newtype = PS["Data.Newtype"];
  var Data_Nullable = PS["Data.Nullable"];
  var Data_Ord = PS["Data.Ord"];
  var Prelude = PS["Prelude"];        
  var QuerySelector = function (x) {
      return x;
  };
  var querySelector = function (qs) {
      return function ($3) {
          return Data_Functor.map(Control_Monad_Eff.functorEff)(Data_Nullable.toMaybe)($foreign._querySelector(qs)($3));
      };
  };                                        
  var newtypeQuerySelector = new Data_Newtype.Newtype(function (n) {
      return n;
  }, QuerySelector);
  exports["QuerySelector"] = QuerySelector;
  exports["querySelector"] = querySelector;
  exports["newtypeQuerySelector"] = newtypeQuerySelector;
  exports["querySelectorAll"] = $foreign.querySelectorAll;
})(PS["DOM.Node.ParentNode"] = PS["DOM.Node.ParentNode"] || {});
(function(exports) {
  // Generated by purs version 0.11.5
  "use strict";
  var Control_Monad_Eff = PS["Control.Monad.Eff"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var DOM = PS["DOM"];
  var DOM_Classy_Util = PS["DOM.Classy.Util"];
  var DOM_HTML_Types = PS["DOM.HTML.Types"];
  var DOM_Node_ParentNode = PS["DOM.Node.ParentNode"];
  var DOM_Node_Types = PS["DOM.Node.Types"];
  var Data_Maybe = PS["Data.Maybe"];
  var Prelude = PS["Prelude"];
  var Unsafe_Coerce = PS["Unsafe.Coerce"];        
  var IsParentNode = function (fromParentNode, toParentNode) {
      this.fromParentNode = fromParentNode;
      this.toParentNode = toParentNode;
  };
  var toParentNode = function (dict) {
      return dict.toParentNode;
  };
  var querySelectorAll = function (dictIsParentNode) {
      return function (selector) {
          return function ($6) {
              return DOM_Node_ParentNode.querySelectorAll(selector)(toParentNode(dictIsParentNode)($6));
          };
      };
  };
  var querySelector = function (dictIsParentNode) {
      return function (selector) {
          return function ($7) {
              return DOM_Node_ParentNode.querySelector(selector)(toParentNode(dictIsParentNode)($7));
          };
      };
  };                                                                                                                          
  var isParentNodeDocument = new IsParentNode(DOM_Classy_Util.fromAny(DOM_Node_Types.readDocument), Unsafe_Coerce.unsafeCoerce);
  var fromParentNode = function (dict) {
      return dict.fromParentNode;
  };
  exports["IsParentNode"] = IsParentNode;
  exports["fromParentNode"] = fromParentNode;
  exports["querySelector"] = querySelector;
  exports["querySelectorAll"] = querySelectorAll;
  exports["toParentNode"] = toParentNode;
  exports["isParentNodeDocument"] = isParentNodeDocument;
})(PS["DOM.Classy.ParentNode"] = PS["DOM.Classy.ParentNode"] || {});
(function(exports) {
  /* global window */
  "use strict";

  exports.window = function () {
    return window;
  };
})(PS["DOM.HTML"] = PS["DOM.HTML"] || {});
(function(exports) {
  // Generated by purs version 0.11.5
  "use strict";
  var $foreign = PS["DOM.HTML"];
  var Control_Monad_Eff = PS["Control.Monad.Eff"];
  var DOM = PS["DOM"];
  var DOM_HTML_Types = PS["DOM.HTML.Types"];
  exports["window"] = $foreign.window;
})(PS["DOM.HTML"] = PS["DOM.HTML"] || {});
(function(exports) {
    "use strict";

  exports.document = function (window) {
    return function () {
      return window.document;
    };
  };

  exports.alert = function (str) {
    return function (window) {
      return function () {
        window.alert(str);
        return {};
      };
    };
  };
})(PS["DOM.HTML.Window"] = PS["DOM.HTML.Window"] || {});
(function(exports) {
  // Generated by purs version 0.11.5
  "use strict";
  var $foreign = PS["DOM.HTML.Window"];
  var Control_Monad_Eff = PS["Control.Monad.Eff"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var DOM = PS["DOM"];
  var DOM_HTML_Types = PS["DOM.HTML.Types"];
  var DOM_WebStorage_Types = PS["DOM.WebStorage.Types"];
  var Data_Eq = PS["Data.Eq"];
  var Data_Functor = PS["Data.Functor"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_Newtype = PS["Data.Newtype"];
  var Data_Nullable = PS["Data.Nullable"];
  var Data_Ord = PS["Data.Ord"];
  var Prelude = PS["Prelude"];
  exports["alert"] = $foreign.alert;
  exports["document"] = $foreign.document;
})(PS["DOM.HTML.Window"] = PS["DOM.HTML.Window"] || {});
(function(exports) {
    "use strict";

  exports.setAttribute = function (name) {
    return function (value) {
      return function (element) {
        return function () {
          element.setAttribute(name, value);
          return {};
        };
      };
    };
  };
})(PS["DOM.Node.Element"] = PS["DOM.Node.Element"] || {});
(function(exports) {
  // Generated by purs version 0.11.5
  "use strict";
  var $foreign = PS["DOM.Node.Element"];
  var Control_Monad_Eff = PS["Control.Monad.Eff"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var DOM = PS["DOM"];
  var DOM_Node_Types = PS["DOM.Node.Types"];
  var Data_Functor = PS["Data.Functor"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_Nullable = PS["Data.Nullable"];
  var Prelude = PS["Prelude"];
  exports["setAttribute"] = $foreign.setAttribute;
})(PS["DOM.Node.Element"] = PS["DOM.Node.Element"] || {});
(function(exports) {
    "use strict";

  exports.toArray = function (list) {
    return function () {
      return [].slice.call(list);
    };
  };
})(PS["DOM.Node.NodeList"] = PS["DOM.Node.NodeList"] || {});
(function(exports) {
  // Generated by purs version 0.11.5
  "use strict";
  var $foreign = PS["DOM.Node.NodeList"];
  var Control_Monad_Eff = PS["Control.Monad.Eff"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var DOM = PS["DOM"];
  var DOM_Node_Types = PS["DOM.Node.Types"];
  var Data_Functor = PS["Data.Functor"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_Nullable = PS["Data.Nullable"];
  var Prelude = PS["Prelude"];
  exports["toArray"] = $foreign.toArray;
})(PS["DOM.Node.NodeList"] = PS["DOM.Node.NodeList"] || {});
(function(exports) {
    "use strict";

  function id(x) {
    return x;
  } 

  var objToString = Object.prototype.toString;

  function isArray(a) {
    return objToString.call(a) === "[object Array]";
  }

  exports._foldJson = function (isNull, isBool, isNum, isStr, isArr, isObj, j) {
    if (j == null) return isNull(null);
    else if (typeof j === "boolean") return isBool(j);
    else if (typeof j === "number") return isNum(j);
    else if (typeof j === "string") return isStr(j);
    else if (objToString.call(j) === "[object Array]")
      return isArr(j);
    else return isObj(j);
  };
})(PS["Data.Argonaut.Core"] = PS["Data.Argonaut.Core"] || {});
(function(exports) {
    "use strict";

  exports._copyEff = function (m) {
    return function () {
      var r = {};
      for (var k in m) {
        if (hasOwnProperty.call(m, k)) {
          r[k] = m[k];
        }
      }
      return r;
    };
  };

  exports.empty = {};

  exports.runST = function (f) {
    return f;
  };

  exports._fmapStrMap = function (m0, f) {
    var m = {};
    for (var k in m0) {
      if (hasOwnProperty.call(m0, k)) {
        m[k] = f(m0[k]);
      }
    }
    return m;
  };

  exports._foldM = function (bind) {
    return function (f) {
      return function (mz) {
        return function (m) {
          var acc = mz;
          function g(k) {
            return function (z) {
              return f(z)(k)(m[k]);
            };
          }
          for (var k in m) {
            if (hasOwnProperty.call(m, k)) {
              acc = bind(acc)(g(k));
            }
          }
          return acc;
        };
      };
    };
  };

  exports._lookup = function (no, yes, k, m) {
    return k in m ? yes(m[k]) : no;
  };

  function toArrayWithKey(f) {
    return function (m) {
      var r = [];
      for (var k in m) {
        if (hasOwnProperty.call(m, k)) {
          r.push(f(k)(m[k]));
        }
      }
      return r;
    };
  }

  exports.toArrayWithKey = toArrayWithKey;
})(PS["Data.StrMap"] = PS["Data.StrMap"] || {});
(function(exports) {
    "use strict";

  //------------------------------------------------------------------------------
  // Array size ------------------------------------------------------------------
  //------------------------------------------------------------------------------

  exports.length = function (xs) {
    return xs.length;
  };

  //------------------------------------------------------------------------------
  // Partial ---------------------------------------------------------------------
  //------------------------------------------------------------------------------

  exports.unsafeIndexImpl = function (xs) {
    return function (n) {
      return xs[n];
    };
  };
})(PS["Data.Array"] = PS["Data.Array"] || {});
(function(exports) {
  // Generated by purs version 0.11.5
  "use strict";
  var $foreign = PS["Data.Array"];
  var Control_Alt = PS["Control.Alt"];
  var Control_Alternative = PS["Control.Alternative"];
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Bind = PS["Control.Bind"];
  var Control_Category = PS["Control.Category"];
  var Control_Lazy = PS["Control.Lazy"];
  var Control_Monad_Eff = PS["Control.Monad.Eff"];
  var Control_Monad_Rec_Class = PS["Control.Monad.Rec.Class"];
  var Control_Monad_ST = PS["Control.Monad.ST"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Data_Array_ST = PS["Data.Array.ST"];
  var Data_Array_ST_Iterator = PS["Data.Array.ST.Iterator"];
  var Data_Boolean = PS["Data.Boolean"];
  var Data_Eq = PS["Data.Eq"];
  var Data_Foldable = PS["Data.Foldable"];
  var Data_Function = PS["Data.Function"];
  var Data_Functor = PS["Data.Functor"];
  var Data_HeytingAlgebra = PS["Data.HeytingAlgebra"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_NonEmpty = PS["Data.NonEmpty"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Ordering = PS["Data.Ordering"];
  var Data_Ring = PS["Data.Ring"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Semiring = PS["Data.Semiring"];
  var Data_Traversable = PS["Data.Traversable"];
  var Data_Tuple = PS["Data.Tuple"];
  var Data_Unfoldable = PS["Data.Unfoldable"];
  var Partial_Unsafe = PS["Partial.Unsafe"];
  var Prelude = PS["Prelude"];                                                        
  var unsafeIndex = function (dictPartial) {
      return $foreign.unsafeIndexImpl;
  }; 
  var toUnfoldable = function (dictUnfoldable) {
      return function (xs) {
          var len = $foreign.length(xs);
          var f = function (i) {
              if (i < len) {
                  return new Data_Maybe.Just(new Data_Tuple.Tuple(unsafeIndex()(xs)(i), i + 1 | 0));
              };
              if (Data_Boolean.otherwise) {
                  return Data_Maybe.Nothing.value;
              };
              throw new Error("Failed pattern match at Data.Array line 134, column 19 - line 139, column 26: " + [ i.constructor.name ]);
          };
          return Data_Unfoldable.unfoldr(dictUnfoldable)(f)(0);
      };
  };
  exports["toUnfoldable"] = toUnfoldable;
  exports["unsafeIndex"] = unsafeIndex;
})(PS["Data.Array"] = PS["Data.Array"] || {});
(function(exports) {
    "use strict";

  exports.poke = function (m) {
    return function (k) {
      return function (v) {
        return function () {
          m[k] = v;
          return m;
        };
      };
    };
  };
})(PS["Data.StrMap.ST"] = PS["Data.StrMap.ST"] || {});
(function(exports) {
  // Generated by purs version 0.11.5
  "use strict";
  var $foreign = PS["Data.StrMap.ST"];
  var Control_Monad_Eff = PS["Control.Monad.Eff"];
  var Control_Monad_ST = PS["Control.Monad.ST"];
  var Data_Maybe = PS["Data.Maybe"];
  exports["poke"] = $foreign.poke;
})(PS["Data.StrMap.ST"] = PS["Data.StrMap.ST"] || {});
(function(exports) {
  // Generated by purs version 0.11.5
  "use strict";
  var $foreign = PS["Data.StrMap"];
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Bind = PS["Control.Bind"];
  var Control_Category = PS["Control.Category"];
  var Control_Monad_Eff = PS["Control.Monad.Eff"];
  var Control_Monad_ST = PS["Control.Monad.ST"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Data_Array = PS["Data.Array"];
  var Data_Eq = PS["Data.Eq"];
  var Data_Foldable = PS["Data.Foldable"];
  var Data_Function = PS["Data.Function"];
  var Data_Function_Uncurried = PS["Data.Function.Uncurried"];
  var Data_Functor = PS["Data.Functor"];
  var Data_HeytingAlgebra = PS["Data.HeytingAlgebra"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_Monoid = PS["Data.Monoid"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Show = PS["Data.Show"];
  var Data_StrMap_ST = PS["Data.StrMap.ST"];
  var Data_Traversable = PS["Data.Traversable"];
  var Data_Tuple = PS["Data.Tuple"];
  var Data_Unfoldable = PS["Data.Unfoldable"];
  var Prelude = PS["Prelude"];        
  var values = $foreign.toArrayWithKey(function (v) {
      return function (v1) {
          return v1;
      };
  });
  var toUnfoldable = function (dictUnfoldable) {
      return function ($44) {
          return Data_Array.toUnfoldable(dictUnfoldable)($foreign.toArrayWithKey(Data_Tuple.Tuple.create)($44));
      };
  };                                                             
  var thawST = $foreign._copyEff;
  var pureST = function (f) {
      return Control_Monad_Eff.runPure($foreign.runST(f));
  };
  var mutate = function (f) {
      return function (m) {
          return pureST(function __do() {
              var v = thawST(m)();
              var v1 = f(v)();
              return v;
          });
      };
  };
  var lookup = Data_Function_Uncurried.runFn4($foreign._lookup)(Data_Maybe.Nothing.value)(Data_Maybe.Just.create);
  var insert = function (k) {
      return function (v) {
          return mutate(function (s) {
              return Data_Functor["void"](Control_Monad_Eff.functorEff)(Data_StrMap_ST.poke(s)(k)(v));
          });
      };
  };
  var functorStrMap = new Data_Functor.Functor(function (f) {
      return function (m) {
          return $foreign._fmapStrMap(m, f);
      };
  });
  var fold = $foreign._foldM(Data_Function.applyFlipped);
  var foldMap = function (dictMonoid) {
      return function (f) {
          return fold(function (acc) {
              return function (k) {
                  return function (v) {
                      return Data_Semigroup.append(dictMonoid.Semigroup0())(acc)(f(k)(v));
                  };
              };
          })(Data_Monoid.mempty(dictMonoid));
      };
  };
  var foldableStrMap = new Data_Foldable.Foldable(function (dictMonoid) {
      return function (f) {
          return foldMap(dictMonoid)(Data_Function["const"](f));
      };
  }, function (f) {
      return fold(function (z) {
          return function (v) {
              return f(z);
          };
      });
  }, function (f) {
      return function (z) {
          return function (m) {
              return Data_Foldable.foldr(Data_Foldable.foldableArray)(f)(z)(values(m));
          };
      };
  });
  var traversableStrMap = new Data_Traversable.Traversable(function () {
      return foldableStrMap;
  }, function () {
      return functorStrMap;
  }, function (dictApplicative) {
      return Data_Traversable.traverse(traversableStrMap)(dictApplicative)(Control_Category.id(Control_Category.categoryFn));
  }, function (dictApplicative) {
      return function (f) {
          return function (ms) {
              return fold(function (acc) {
                  return function (k) {
                      return function (v) {
                          return Control_Apply.apply(dictApplicative.Apply0())(Data_Functor.map((dictApplicative.Apply0()).Functor0())(insert(k))(f(v)))(acc);
                      };
                  };
              })(Control_Applicative.pure(dictApplicative)($foreign.empty))(ms);
          };
      };
  });
  exports["fold"] = fold;
  exports["foldMap"] = foldMap;
  exports["insert"] = insert;
  exports["lookup"] = lookup;
  exports["pureST"] = pureST;
  exports["thawST"] = thawST;
  exports["toUnfoldable"] = toUnfoldable;
  exports["values"] = values;
  exports["functorStrMap"] = functorStrMap;
  exports["foldableStrMap"] = foldableStrMap;
  exports["traversableStrMap"] = traversableStrMap;
})(PS["Data.StrMap"] = PS["Data.StrMap"] || {});
(function(exports) {
  // Generated by purs version 0.11.5
  "use strict";
  var $foreign = PS["Data.Argonaut.Core"];
  var Data_Eq = PS["Data.Eq"];
  var Data_Function = PS["Data.Function"];
  var Data_Function_Uncurried = PS["Data.Function.Uncurried"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Ordering = PS["Data.Ordering"];
  var Data_Show = PS["Data.Show"];
  var Data_StrMap = PS["Data.StrMap"];
  var Data_Tuple = PS["Data.Tuple"];
  var Prelude = PS["Prelude"];
  var Unsafe_Coerce = PS["Unsafe.Coerce"];        
  var verbJsonType = function (def) {
      return function (f) {
          return function (fold) {
              return fold(def)(f);
          };
      };
  };
  var toJsonType = verbJsonType(Data_Maybe.Nothing.value)(Data_Maybe.Just.create);
  var foldJsonString = function (d) {
      return function (f) {
          return function (j) {
              return $foreign._foldJson(Data_Function["const"](d), Data_Function["const"](d), Data_Function["const"](d), f, Data_Function["const"](d), Data_Function["const"](d), j);
          };
      };
  };                                        
  var foldJsonObject = function (d) {
      return function (f) {
          return function (j) {
              return $foreign._foldJson(Data_Function["const"](d), Data_Function["const"](d), Data_Function["const"](d), Data_Function["const"](d), Data_Function["const"](d), f, j);
          };
      };
  };                                        
  var toObject = toJsonType(foldJsonObject);
  var foldJsonNumber = function (d) {
      return function (f) {
          return function (j) {
              return $foreign._foldJson(Data_Function["const"](d), Data_Function["const"](d), f, Data_Function["const"](d), Data_Function["const"](d), Data_Function["const"](d), j);
          };
      };
  };                                          
  var foldJsonArray = function (d) {
      return function (f) {
          return function (j) {
              return $foreign._foldJson(Data_Function["const"](d), Data_Function["const"](d), Data_Function["const"](d), Data_Function["const"](d), f, Data_Function["const"](d), j);
          };
      };
  };                                      
  var toArray = toJsonType(foldJsonArray);
  exports["foldJsonArray"] = foldJsonArray;
  exports["foldJsonNumber"] = foldJsonNumber;
  exports["foldJsonObject"] = foldJsonObject;
  exports["foldJsonString"] = foldJsonString;
  exports["toArray"] = toArray;
  exports["toObject"] = toObject;
})(PS["Data.Argonaut.Core"] = PS["Data.Argonaut.Core"] || {});
(function(exports) {
  // Generated by purs version 0.11.5
  "use strict";
  var Control_Alt = PS["Control.Alt"];
  var Control_Alternative = PS["Control.Alternative"];
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Bind = PS["Control.Bind"];
  var Control_Category = PS["Control.Category"];
  var Control_Lazy = PS["Control.Lazy"];
  var Control_Monad_Rec_Class = PS["Control.Monad.Rec.Class"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Data_Bifunctor = PS["Data.Bifunctor"];
  var Data_Boolean = PS["Data.Boolean"];
  var Data_Eq = PS["Data.Eq"];
  var Data_Foldable = PS["Data.Foldable"];
  var Data_Function = PS["Data.Function"];
  var Data_Functor = PS["Data.Functor"];
  var Data_HeytingAlgebra = PS["Data.HeytingAlgebra"];
  var Data_List_Types = PS["Data.List.Types"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_Newtype = PS["Data.Newtype"];
  var Data_NonEmpty = PS["Data.NonEmpty"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Ordering = PS["Data.Ordering"];
  var Data_Ring = PS["Data.Ring"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Semiring = PS["Data.Semiring"];
  var Data_Show = PS["Data.Show"];
  var Data_Traversable = PS["Data.Traversable"];
  var Data_Tuple = PS["Data.Tuple"];
  var Data_Unfoldable = PS["Data.Unfoldable"];
  var Data_Unit = PS["Data.Unit"];
  var Prelude = PS["Prelude"];
  var fromFoldable = function (dictFoldable) {
      return Data_Foldable.foldr(dictFoldable)(Data_List_Types.Cons.create)(Data_List_Types.Nil.value);
  };
  exports["fromFoldable"] = fromFoldable;
})(PS["Data.List"] = PS["Data.List"] || {});
(function(exports) {
  // Generated by purs version 0.11.5
  "use strict";
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Category = PS["Control.Category"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Data_Eq = PS["Data.Eq"];
  var Data_Foldable = PS["Data.Foldable"];
  var Data_Function = PS["Data.Function"];
  var Data_Functor = PS["Data.Functor"];
  var Data_HeytingAlgebra = PS["Data.HeytingAlgebra"];
  var Data_List = PS["Data.List"];
  var Data_List_Lazy = PS["Data.List.Lazy"];
  var Data_List_Lazy_Types = PS["Data.List.Lazy.Types"];
  var Data_List_Types = PS["Data.List.Types"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_Monoid = PS["Data.Monoid"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Ordering = PS["Data.Ordering"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Semiring = PS["Data.Semiring"];
  var Data_Show = PS["Data.Show"];
  var Data_Traversable = PS["Data.Traversable"];
  var Data_Tuple = PS["Data.Tuple"];
  var Data_Unfoldable = PS["Data.Unfoldable"];
  var Partial_Unsafe = PS["Partial.Unsafe"];
  var Prelude = PS["Prelude"];        
  var Leaf = (function () {
      function Leaf() {

      };
      Leaf.value = new Leaf();
      return Leaf;
  })();
  var Two = (function () {
      function Two(value0, value1, value2, value3) {
          this.value0 = value0;
          this.value1 = value1;
          this.value2 = value2;
          this.value3 = value3;
      };
      Two.create = function (value0) {
          return function (value1) {
              return function (value2) {
                  return function (value3) {
                      return new Two(value0, value1, value2, value3);
                  };
              };
          };
      };
      return Two;
  })();
  var Three = (function () {
      function Three(value0, value1, value2, value3, value4, value5, value6) {
          this.value0 = value0;
          this.value1 = value1;
          this.value2 = value2;
          this.value3 = value3;
          this.value4 = value4;
          this.value5 = value5;
          this.value6 = value6;
      };
      Three.create = function (value0) {
          return function (value1) {
              return function (value2) {
                  return function (value3) {
                      return function (value4) {
                          return function (value5) {
                              return function (value6) {
                                  return new Three(value0, value1, value2, value3, value4, value5, value6);
                              };
                          };
                      };
                  };
              };
          };
      };
      return Three;
  })();
  var singleton = function (k) {
      return function (v) {
          return new Two(Leaf.value, k, v, Leaf.value);
      };
  };
  var lookup = function (dictOrd) {
      return function (k) {
          var comp = Data_Ord.compare(dictOrd);
          var go = function ($copy_v) {
              var $tco_done = false;
              var $tco_result;
              function $tco_loop(v) {
                  if (v instanceof Leaf) {
                      $tco_done = true;
                      return Data_Maybe.Nothing.value;
                  };
                  if (v instanceof Two) {
                      var v2 = comp(k)(v.value1);
                      if (v2 instanceof Data_Ordering.EQ) {
                          $tco_done = true;
                          return new Data_Maybe.Just(v.value2);
                      };
                      if (v2 instanceof Data_Ordering.LT) {
                          $copy_v = v.value0;
                          return;
                      };
                      $copy_v = v.value3;
                      return;
                  };
                  if (v instanceof Three) {
                      var v3 = comp(k)(v.value1);
                      if (v3 instanceof Data_Ordering.EQ) {
                          $tco_done = true;
                          return new Data_Maybe.Just(v.value2);
                      };
                      var v4 = comp(k)(v.value4);
                      if (v4 instanceof Data_Ordering.EQ) {
                          $tco_done = true;
                          return new Data_Maybe.Just(v.value5);
                      };
                      if (v3 instanceof Data_Ordering.LT) {
                          $copy_v = v.value0;
                          return;
                      };
                      if (v4 instanceof Data_Ordering.GT) {
                          $copy_v = v.value6;
                          return;
                      };
                      $copy_v = v.value3;
                      return;
                  };
                  throw new Error("Failed pattern match at Data.Map line 157, column 12 - line 176, column 29: " + [ v.constructor.name ]);
              };
              while (!$tco_done) {
                  $tco_result = $tco_loop($copy_v);
              };
              return $tco_result;
          };
          return go;
      };
  };
  var member = function (dictOrd) {
      return function (k) {
          return function (m) {
              return Data_Maybe.isJust(lookup(dictOrd)(k)(m));
          };
      };
  };
  exports["lookup"] = lookup;
  exports["member"] = member;
  exports["singleton"] = singleton;
})(PS["Data.Map"] = PS["Data.Map"] || {});
(function(exports) {
  // Generated by purs version 0.11.5
  "use strict";
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Bind = PS["Control.Bind"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Data_Argonaut_Core = PS["Data.Argonaut.Core"];
  var Data_Bifunctor = PS["Data.Bifunctor"];
  var Data_Boolean = PS["Data.Boolean"];
  var Data_Either = PS["Data.Either"];
  var Data_Foldable = PS["Data.Foldable"];
  var Data_Function = PS["Data.Function"];
  var Data_Functor = PS["Data.Functor"];
  var Data_Int = PS["Data.Int"];
  var Data_List = PS["Data.List"];
  var Data_List_Types = PS["Data.List.Types"];
  var Data_Map = PS["Data.Map"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Show = PS["Data.Show"];
  var Data_StrMap = PS["Data.StrMap"];
  var Data_String = PS["Data.String"];
  var Data_Traversable = PS["Data.Traversable"];
  var Data_Tuple = PS["Data.Tuple"];
  var Data_Unit = PS["Data.Unit"];
  var Prelude = PS["Prelude"];        
  var DecodeJson = function (decodeJson) {
      this.decodeJson = decodeJson;
  }; 
  var decodeJsonString = new DecodeJson(Data_Argonaut_Core.foldJsonString(new Data_Either.Left("Value is not a String"))(Data_Either.Right.create));
  var decodeJsonNumber = new DecodeJson(Data_Argonaut_Core.foldJsonNumber(new Data_Either.Left("Value is not a Number"))(Data_Either.Right.create));                               
  var decodeJsonJson = new DecodeJson(Data_Either.Right.create);                                                                                       
  var decodeJson = function (dict) {
      return dict.decodeJson;
  }; 
  var decodeJsonInt = new DecodeJson(Control_Bind.composeKleisliFlipped(Data_Either.bindEither)(function ($32) {
      return Data_Maybe.maybe(new Data_Either.Left("Value is not an integer"))(Data_Either.Right.create)(Data_Int.fromNumber($32));
  })(decodeJson(decodeJsonNumber)));
  var decodeJObject = function ($33) {
      return Data_Maybe.maybe(new Data_Either.Left("Value is not an Object"))(Data_Either.Right.create)(Data_Argonaut_Core.toObject($33));
  };
  var decodeStrMap = function (dictDecodeJson) {
      return new DecodeJson(function ($34) {
          return Data_Bifunctor.lmap(Data_Either.bifunctorEither)(function (v) {
              return "Couldn't decode StrMap: " + v;
          })(Control_Bind.composeKleisliFlipped(Data_Either.bindEither)(Data_Traversable.traverse(Data_StrMap.traversableStrMap)(Data_Either.applicativeEither)(decodeJson(dictDecodeJson)))(decodeJObject)($34));
      });
  };
  var decodeJArray = function ($35) {
      return Data_Maybe.maybe(new Data_Either.Left("Value is not an Array"))(Data_Either.Right.create)(Data_Argonaut_Core.toArray($35));
  };
  var decodeList = function (dictDecodeJson) {
      return new DecodeJson(function ($36) {
          return Data_Bifunctor.lmap(Data_Either.bifunctorEither)(function (v) {
              return "Couldn't decode List: " + v;
          })(Control_Bind.composeKleisliFlipped(Data_Either.bindEither)(Data_Traversable.traverse(Data_List_Types.traversableList)(Data_Either.applicativeEither)(decodeJson(dictDecodeJson)))(Data_Functor.map(Data_Functor.functorFn)(Data_Functor.map(Data_Either.functorEither)(Data_List.fromFoldable(Data_Foldable.foldableArray)))(decodeJArray))($36));
      });
  };
  var decodeJsonTuple = function (dictDecodeJson) {
      return function (dictDecodeJson1) {
          return new DecodeJson(function (j) {
              var f = function (v) {
                  if (v instanceof Data_List_Types.Cons && (v.value1 instanceof Data_List_Types.Cons && v.value1.value1 instanceof Data_List_Types.Nil)) {
                      return Control_Apply.apply(Data_Either.applyEither)(Data_Functor.map(Data_Either.functorEither)(Data_Tuple.Tuple.create)(decodeJson(dictDecodeJson)(v.value0)))(decodeJson(dictDecodeJson1)(v.value1.value0));
                  };
                  return new Data_Either.Left("Couldn't decode Tuple");
              };
              return Control_Bind.bind(Data_Either.bindEither)(decodeJson(decodeList(decodeJsonJson))(j))(f);
          });
      };
  };
  var decodeArray = function (dictDecodeJson) {
      return new DecodeJson(function ($38) {
          return Data_Bifunctor.lmap(Data_Either.bifunctorEither)(function (v) {
              return "Couldn't decode Array: " + v;
          })(Control_Bind.composeKleisliFlipped(Data_Either.bindEither)(Data_Traversable.traverse(Data_Traversable.traversableArray)(Data_Either.applicativeEither)(decodeJson(dictDecodeJson)))(decodeJArray)($38));
      });
  };
  exports["DecodeJson"] = DecodeJson;
  exports["decodeJson"] = decodeJson;
  exports["decodeJsonTuple"] = decodeJsonTuple;
  exports["decodeJsonNumber"] = decodeJsonNumber;
  exports["decodeJsonInt"] = decodeJsonInt;
  exports["decodeJsonString"] = decodeJsonString;
  exports["decodeJsonJson"] = decodeJsonJson;
  exports["decodeStrMap"] = decodeStrMap;
  exports["decodeArray"] = decodeArray;
  exports["decodeList"] = decodeList;
})(PS["Data.Argonaut.Decode.Class"] = PS["Data.Argonaut.Decode.Class"] || {});
(function(exports) {
  // Generated by purs version 0.11.5
  "use strict";
  var Control_Applicative = PS["Control.Applicative"];
  var Data_Argonaut_Core = PS["Data.Argonaut.Core"];
  var Data_Argonaut_Decode_Class = PS["Data.Argonaut.Decode.Class"];
  var Data_Either = PS["Data.Either"];
  var Data_Function = PS["Data.Function"];
  var Data_Functor = PS["Data.Functor"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Show = PS["Data.Show"];
  var Data_StrMap = PS["Data.StrMap"];
  var Prelude = PS["Prelude"];
  var getField = function (dictDecodeJson) {
      return function (o) {
          return function (s) {
              return Data_Maybe.maybe(Data_Either.Left.create("Expected field " + Data_Show.show(Data_Show.showString)(s)))(Data_Argonaut_Decode_Class.decodeJson(dictDecodeJson))(Data_StrMap.lookup(s)(o));
          };
      };
  };
  exports["getField"] = getField;
})(PS["Data.Argonaut.Decode.Combinators"] = PS["Data.Argonaut.Decode.Combinators"] || {});
(function(exports) {
    "use strict";
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Bind = PS["Control.Bind"];
  var Control_Extend = PS["Control.Extend"];
  var Control_Monad = PS["Control.Monad"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Data_Eq = PS["Data.Eq"];
  var Data_Foldable = PS["Data.Foldable"];
  var Data_Function = PS["Data.Function"];
  var Data_Functor = PS["Data.Functor"];
  var Data_Generic_Rep = PS["Data.Generic.Rep"];
  var Data_List = PS["Data.List"];
  var Data_List_Types = PS["Data.List.Types"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_Monoid = PS["Data.Monoid"];
  var Data_Newtype = PS["Data.Newtype"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Tuple = PS["Data.Tuple"];
  var Data_Unfoldable = PS["Data.Unfoldable"];
  var Prelude = PS["Prelude"];

  // | Like `left`, but, y'know, backwards.
  var right = function (v) {
      if (v.value1 instanceof Data_List_Types.Nil) {
          return Data_Maybe.Nothing.value;
      };
      if (v.value1 instanceof Data_List_Types.Cons) {
          return new Data_Maybe.Just(new Data_Tuple.Tuple(new Data_Tuple.Tuple(new Data_List_Types.Cons(v.value1.value0, v.value0), v.value1.value1), v.value1.value0));
      };
      throw new Error("Failed pattern match at Data.Chain line 135, column 1 - line 135, column 38: " + [ v.constructor.name ]);
  };        

  // | Move to the `left`. If we can't, it's a `Nothing`. If we can, we

  // | get the `Chain` in the new position, and the value we passed.
  var left = function (v) {
      if (v.value0 instanceof Data_List_Types.Nil) {
          return Data_Maybe.Nothing.value;
      };
      if (v.value0 instanceof Data_List_Types.Cons) {
          return new Data_Maybe.Just(new Data_Tuple.Tuple(new Data_Tuple.Tuple(v.value0.value1, new Data_List_Types.Cons(v.value0.value0, v.value1)), v.value0.value0));
      };
      throw new Error("Failed pattern match at Data.Chain line 128, column 1 - line 128, column 37: " + [ v.constructor.name ]);
  }; 

  // | Transform a `Foldable` type into a `Chain`, where ethe pointer is

  // | right at the beginning (i.e. the `before` list is empty).
  var fromFoldable = function (dictFoldable) {
      return function (xs) {
          return new Data_Tuple.Tuple(Data_List_Types.Nil.value, Data_List.fromFoldable(dictFoldable)(xs));
      };
  };
  exports["fromFoldable"] = fromFoldable;
  exports["left"] = left;
  exports["right"] = right;
})(PS["Data.Chain"] = PS["Data.Chain"] || {});
(function(exports) {
  // Generated by purs version 0.11.5
  "use strict";
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Bind = PS["Control.Bind"];
  var Control_Monad_Eff = PS["Control.Monad.Eff"];
  var Control_Monad_Rec_Class = PS["Control.Monad.Rec.Class"];
  var Control_Monad_ST = PS["Control.Monad.ST"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Data_Array = PS["Data.Array"];
  var Data_Array_ST = PS["Data.Array.ST"];
  var Data_Eq = PS["Data.Eq"];
  var Data_Foldable = PS["Data.Foldable"];
  var Data_Function = PS["Data.Function"];
  var Data_HeytingAlgebra = PS["Data.HeytingAlgebra"];
  var Data_List = PS["Data.List"];
  var Data_List_Types = PS["Data.List.Types"];
  var Data_Map = PS["Data.Map"];
  var Data_Monoid = PS["Data.Monoid"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Ordering = PS["Data.Ordering"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Semiring = PS["Data.Semiring"];
  var Data_Show = PS["Data.Show"];
  var Data_Unfoldable = PS["Data.Unfoldable"];
  var Data_Unit = PS["Data.Unit"];
  var Partial_Unsafe = PS["Partial.Unsafe"];
  var Prelude = PS["Prelude"];        
  var $$Set = (function () {
      function $$Set(value0) {
          this.value0 = value0;
      };
      $$Set.create = function (value0) {
          return new $$Set(value0);
      };
      return $$Set;
  })();
  var singleton = function (a) {
      return new $$Set(Data_Map.singleton(a)(Data_Unit.unit));
  };
  var member = function (dictOrd) {
      return function (a) {
          return function (v) {
              return Data_Map.member(dictOrd)(a)(v.value0);
          };
      };
  };
  exports["member"] = member;
  exports["singleton"] = singleton;
})(PS["Data.Set"] = PS["Data.Set"] || {});
(function(exports) {
  // Generated by purs version 0.11.5
  "use strict";
  var Data_Boolean = PS["Data.Boolean"];
  var Data_EuclideanRing = PS["Data.EuclideanRing"];
  var Data_Function = PS["Data.Function"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Ring = PS["Data.Ring"];
  var Data_Semiring = PS["Data.Semiring"];
  var $$Math = PS["Math"];
  var Prelude = PS["Prelude"];
  var polynomial = function (power) {
      return function (start) {
          return function (end) {
              return function (progress) {
                  return $$Math.pow(progress)(power) * (end - start) + start;
              };
          };
      };
  };
  exports["polynomial"] = polynomial;
})(PS["Easing"] = PS["Easing"] || {});
(function(exports) {
    "use strict";

  exports.mapImpl = function (f) {
    return function(e) {
      return function (sub) {
        e(function(a) {
          sub(f(a));
        });
      }
    };
  };

  exports.applyImpl = function (e1) {
    return function (e2) {
      return function(sub) {
        var a_latest, b_latest;
        var a_fired = false, b_fired = false;

        e1(function(a) {
          a_latest = a;
          a_fired = true;

          if (b_fired) {
            sub(a_latest(b_latest));
          }
        });

        e2(function(b) {
          b_latest = b;
          b_fired = true;

          if (a_fired) {
            sub(a_latest(b_latest));
          }
        });
      };
    };
  };

  exports.mergeImpl = function (e1) {
    return function(e2) {
      return function(sub) {
        e1(sub);
        e2(sub);
      }
    };
  };

  exports.fold = function (f) {
    return function(e) {
      return function(b) {
        return function(sub) {
          var result = b;

          e(function(a) {
            sub(result = f(a)(result));
          });
        };
      };
    };
  };

  exports.filter = function (p) {
    return function(e) {
      return function(sub) {
        e(function(a) {
          if (p(a)) {
            sub(a);
          }
        });
      };
    };
  };

  exports.sampleOn = function (e1) {
    return function (e2) {
      return function(sub) {
        var latest;
        var fired = false;

        e1(function(a) {
          latest = a;
          fired = true;
        });

        e2(function(f) {
          if (fired) {
            sub(f(latest));
          }
        });
      };
    };
  };

  exports.subscribe = function (e) {
    return function(f) {
      return function() {
        e(function(a) {
          f(a)();
        });
      };
    };
  };

  exports.create = function () {
    var subs = [];
    return {
      event: function(sub) {
        subs.push(sub);
      },
      push: function(a) {
        return function() {
          for (var i = 0; i < subs.length; i++) {
            subs[i](a);
          }
        };
      }
    };
  };
})(PS["FRP.Event"] = PS["FRP.Event"] || {});
(function(exports) {
  // Generated by purs version 0.11.5
  "use strict";
  var $foreign = PS["FRP.Event"];
  var Control_Alt = PS["Control.Alt"];
  var Control_Alternative = PS["Control.Alternative"];
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Category = PS["Control.Category"];
  var Control_Monad_Eff = PS["Control.Monad.Eff"];
  var Control_Plus = PS["Control.Plus"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Data_Function = PS["Data.Function"];
  var Data_Functor = PS["Data.Functor"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_Monoid = PS["Data.Monoid"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Semiring = PS["Data.Semiring"];
  var Data_Tuple = PS["Data.Tuple"];
  var FRP = PS["FRP"];
  var Partial_Unsafe = PS["Partial.Unsafe"];
  var Prelude = PS["Prelude"];        
  var functorEvent = new Data_Functor.Functor($foreign.mapImpl);
  var mapMaybe = function (f) {
      return function ($14) {
          return Data_Functor.map(functorEvent)(Data_Maybe.fromJust())($foreign.filter(Data_Maybe.isJust)(Data_Functor.map(functorEvent)(f)($14)));
      };
  };
  var withLast = function (e) {
      var step = function (a) {
          return function (v) {
              if (v instanceof Data_Maybe.Nothing) {
                  return new Data_Maybe.Just({
                      now: a, 
                      last: Data_Maybe.Nothing.value
                  });
              };
              if (v instanceof Data_Maybe.Just) {
                  return new Data_Maybe.Just({
                      now: a, 
                      last: new Data_Maybe.Just(v.value0.now)
                  });
              };
              throw new Error("Failed pattern match at FRP.Event line 97, column 3 - line 97, column 60: " + [ a.constructor.name, v.constructor.name ]);
          };
      };
      return mapMaybe(Control_Category.id(Control_Category.categoryFn))($foreign.fold(step)(e)(Data_Maybe.Nothing.value));
  };
  var sampleOn_ = function (a) {
      return function (b) {
          return $foreign.sampleOn(a)(Data_Functor.voidLeft(functorEvent)(b)(Control_Category.id(Control_Category.categoryFn)));
      };
  };
  var applyEvent = new Control_Apply.Apply(function () {
      return functorEvent;
  }, $foreign.applyImpl);
  var altEvent = new Control_Alt.Alt(function () {
      return functorEvent;
  }, $foreign.mergeImpl);
  exports["mapMaybe"] = mapMaybe;
  exports["sampleOn_"] = sampleOn_;
  exports["withLast"] = withLast;
  exports["functorEvent"] = functorEvent;
  exports["applyEvent"] = applyEvent;
  exports["altEvent"] = altEvent;
  exports["create"] = $foreign.create;
  exports["filter"] = $foreign.filter;
  exports["fold"] = $foreign.fold;
  exports["subscribe"] = $foreign.subscribe;
})(PS["FRP.Event"] = PS["FRP.Event"] || {});
(function(exports) {
    "use strict";

  exports.down = function(sub) {
    addEventListener("keydown", function(e) {
      sub(e.keyCode);
    });
  };
})(PS["FRP.Event.Keyboard"] = PS["FRP.Event.Keyboard"] || {});
(function(exports) {
  // Generated by purs version 0.11.5
  "use strict";
  var $foreign = PS["FRP.Event.Keyboard"];
  var FRP_Event = PS["FRP.Event"];
  exports["down"] = $foreign.down;
})(PS["FRP.Event.Keyboard"] = PS["FRP.Event.Keyboard"] || {});
(function(exports) {
    "use strict";

  exports.animationFrame = function(sub) {
    var loop = function() {
      window.requestAnimationFrame(function() {
        sub();
        loop();
      });
    };
    loop();
  };

  exports.withTime = function (e) {
    return function(sub) {
      e(function(a) {
        var time = new Date().getTime();
        sub({ time: time, value: a });
      });
    };
  };
})(PS["FRP.Event.Time"] = PS["FRP.Event.Time"] || {});
(function(exports) {
  // Generated by purs version 0.11.5
  "use strict";
  var $foreign = PS["FRP.Event.Time"];
  var Data_Unit = PS["Data.Unit"];
  var FRP_Event = PS["FRP.Event"];
  exports["animationFrame"] = $foreign.animationFrame;
  exports["withTime"] = $foreign.withTime;
})(PS["FRP.Event.Time"] = PS["FRP.Event.Time"] || {});
(function(exports) {
    "use strict";
  var Control_Alt = PS["Control.Alt"];
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Bind = PS["Control.Bind"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Data_Argonaut_Core = PS["Data.Argonaut.Core"];
  var Data_Argonaut_Decode_Class = PS["Data.Argonaut.Decode.Class"];
  var Data_Argonaut_Decode_Combinators = PS["Data.Argonaut.Decode.Combinators"];
  var Data_Either = PS["Data.Either"];
  var Data_Function = PS["Data.Function"];
  var Data_Functor = PS["Data.Functor"];
  var Data_Newtype = PS["Data.Newtype"];
  var Data_StrMap = PS["Data.StrMap"];
  var Data_Traversable = PS["Data.Traversable"];
  var Data_Tuple = PS["Data.Tuple"];
  var Prelude = PS["Prelude"];        

  // | A `StyleSpec` is the building block of animations in your JSON!

  // | The `Tuple` values indicate a `start` and `end` value for the

  // | properties, which is rather neat. Oh, one more thing: rotation is

  // | normalised such that `1.0` is a 2r/360 rotation. _C'est tout!_
  var StyleSpec = function (x) {
      return x;
  };

  // | A `KeyframeSpec` defines a `duration` for which to animate the

  // | `StrMap StyleSpec`. The `String` key is a query selector for the

  // | element being animated. Nothing too frightening :)
  var KeyframeSpec = function (x) {
      return x;
  };

  // | The `SceneSpec` is kinda the same thing as the "slide" in your

  // | Favourite Presentation-Editing Software. The `container` tells

  // | us how to find the element that acts as our "slide", and the

  // | `keyframes` are the animations that will happen on the slide. We

  // | do have one _slight_ advantage over the usual software, though...

  // | your animations aren't confined to the slide! You can have an

  // | element independent of your slides that can be animated at any

  // | point. That's pretty neat, I think.
  var SceneSpec = function (x) {
      return x;
  };

  // | The entire configuration for a slideshow is really just an array

  // | of `SceneSpec` values. A presentation is a set of slides to show.

  // | A show of slides. A *slideshow*. Sedimentary, my dear Watson.
  var ConfigSpec = function (x) {
      return x;
  };               
  var newtypeConfigSpec = new Data_Newtype.Newtype(function (n) {
      return n;
  }, ConfigSpec);

  // | Decode a JSON blob into a `StyleSpec`. Well, *try* to, anyway. It could all

  // | go horribly wrong, of course. _Luckily_, `Argonaut` has some pretty great

  // | errors, so it'll let you know if you need to fix up your JSON.
  var decodeJsonStyleSpec = new Data_Argonaut_Decode_Class.DecodeJson((function () {
      var fallback = function (dictApplicative) {
          return function (x) {
              return Control_Applicative.pure(dictApplicative)(new Data_Tuple.Tuple(x, x));
          };
      };
      return Control_Bind.composeKleisli(Data_Either.bindEither)(Data_Argonaut_Decode_Class.decodeJson(Data_Argonaut_Decode_Class.decodeStrMap(Data_Argonaut_Decode_Class.decodeJsonJson)))(function (json) {
          return Data_Functor.map(Data_Either.functorEither)(StyleSpec)(Control_Apply.apply(Data_Either.applyEither)(Control_Apply.apply(Data_Either.applyEither)(Control_Apply.apply(Data_Either.applyEither)(Control_Apply.apply(Data_Either.applyEither)(Data_Functor.map(Data_Either.functorEither)(function (v) {
              return function (v1) {
                  return function (v2) {
                      return function (v3) {
                          return function (v4) {
                              return {
                                  opacity: v, 
                                  rotate: v1, 
                                  scale: v2, 
                                  translateX: v3, 
                                  translateY: v4
                              };
                          };
                      };
                  };
              };
          })(Control_Alt.alt(Data_Either.altEither)(Control_Bind.bind(Data_Either.bindEither)(Data_Argonaut_Decode_Combinators.getField(Data_Argonaut_Decode_Class.decodeJsonJson)(json)("opacity"))(Data_Argonaut_Decode_Class.decodeJson(Data_Argonaut_Decode_Class.decodeJsonTuple(Data_Argonaut_Decode_Class.decodeJsonNumber)(Data_Argonaut_Decode_Class.decodeJsonNumber))))(fallback(Data_Either.applicativeEither)(1.0))))(Control_Alt.alt(Data_Either.altEither)(Control_Bind.bind(Data_Either.bindEither)(Data_Argonaut_Decode_Combinators.getField(Data_Argonaut_Decode_Class.decodeJsonJson)(json)("rotate"))(Data_Argonaut_Decode_Class.decodeJson(Data_Argonaut_Decode_Class.decodeJsonTuple(Data_Argonaut_Decode_Class.decodeJsonNumber)(Data_Argonaut_Decode_Class.decodeJsonNumber))))(fallback(Data_Either.applicativeEither)(0.0))))(Control_Alt.alt(Data_Either.altEither)(Control_Bind.bind(Data_Either.bindEither)(Data_Argonaut_Decode_Combinators.getField(Data_Argonaut_Decode_Class.decodeJsonJson)(json)("scale"))(Data_Argonaut_Decode_Class.decodeJson(Data_Argonaut_Decode_Class.decodeJsonTuple(Data_Argonaut_Decode_Class.decodeJsonNumber)(Data_Argonaut_Decode_Class.decodeJsonNumber))))(fallback(Data_Either.applicativeEither)(1.0))))(Control_Alt.alt(Data_Either.altEither)(Control_Bind.bind(Data_Either.bindEither)(Data_Argonaut_Decode_Combinators.getField(Data_Argonaut_Decode_Class.decodeJsonJson)(json)("translateX"))(Data_Argonaut_Decode_Class.decodeJson(Data_Argonaut_Decode_Class.decodeJsonTuple(Data_Argonaut_Decode_Class.decodeJsonNumber)(Data_Argonaut_Decode_Class.decodeJsonNumber))))(fallback(Data_Either.applicativeEither)(0.0))))(Control_Alt.alt(Data_Either.altEither)(Control_Bind.bind(Data_Either.bindEither)(Data_Argonaut_Decode_Combinators.getField(Data_Argonaut_Decode_Class.decodeJsonJson)(json)("translateY"))(Data_Argonaut_Decode_Class.decodeJson(Data_Argonaut_Decode_Class.decodeJsonTuple(Data_Argonaut_Decode_Class.decodeJsonNumber)(Data_Argonaut_Decode_Class.decodeJsonNumber))))(fallback(Data_Either.applicativeEither)(0.0))));
      });
  })());

  // | This one's a lottle easier to decode as we don't have any data

  // | that we wouldn't mind people skipping. If you can't give us a

  // | duration and a set of styles to animate, you probably don't want

  // | a `Keyframe`!
  var decodeJsonKeyframeSpec = new Data_Argonaut_Decode_Class.DecodeJson(Control_Bind.composeKleisli(Data_Either.bindEither)(Data_Argonaut_Decode_Class.decodeJson(Data_Argonaut_Decode_Class.decodeStrMap(Data_Argonaut_Decode_Class.decodeJsonJson)))(function (json) {
      return Data_Functor.map(Data_Either.functorEither)(KeyframeSpec)(Control_Apply.apply(Data_Either.applyEither)(Data_Functor.map(Data_Either.functorEither)(function (v) {
          return function (v1) {
              return {
                  duration: v, 
                  styles: v1
              };
          };
      })(Data_Argonaut_Decode_Combinators.getField(Data_Argonaut_Decode_Class.decodeJsonInt)(json)("duration")))(Data_Argonaut_Decode_Combinators.getField(Data_Argonaut_Decode_Class.decodeStrMap(decodeJsonStyleSpec))(json)("styles")));
  }));

  // | So, we can decode a JSON blob into some `SceneSpec` type without

  // | much trouble. Maybe we want boring slides? No problem; we can

  // | simply use an empty `keyframes` array, or omit it entirely!
  var decodeJsonSceneSpec = new Data_Argonaut_Decode_Class.DecodeJson(Control_Bind.composeKleisli(Data_Either.bindEither)(Data_Argonaut_Decode_Class.decodeJson(Data_Argonaut_Decode_Class.decodeStrMap(Data_Argonaut_Decode_Class.decodeJsonJson)))(function (json) {
      return Data_Functor.map(Data_Either.functorEither)(SceneSpec)(Control_Apply.apply(Data_Either.applyEither)(Data_Functor.map(Data_Either.functorEither)(function (v) {
          return function (v1) {
              return {
                  container: v, 
                  keyframes: v1
              };
          };
      })(Control_Bind.bind(Data_Either.bindEither)(Data_Argonaut_Decode_Combinators.getField(Data_Argonaut_Decode_Class.decodeJsonJson)(json)("container"))(Data_Argonaut_Decode_Class.decodeJson(Data_Argonaut_Decode_Class.decodeJsonString))))(Control_Alt.alt(Data_Either.altEither)(Control_Bind.bind(Data_Either.bindEither)(Data_Argonaut_Decode_Combinators.getField(Data_Argonaut_Decode_Class.decodeArray(Data_Argonaut_Decode_Class.decodeJsonJson))(json)("keyframes"))(Data_Traversable.traverse(Data_Traversable.traversableArray)(Data_Either.applicativeEither)(Data_Argonaut_Decode_Class.decodeJson(decodeJsonKeyframeSpec))))(Control_Applicative.pure(Data_Either.applicativeEither)([  ]))));
  }));

  // | Oh, this little thing? Pretty snazzy, right? Decode a JSON array

  // | into an `Array SceneSpec`, then wrap it up in a `ConfigSpec`.

  // | *Bosh*.
  var decodeJsonConfigSpec = new Data_Argonaut_Decode_Class.DecodeJson(function ($22) {
      return Data_Functor.map(Data_Either.functorEither)(ConfigSpec)(Data_Argonaut_Decode_Class.decodeJson(Data_Argonaut_Decode_Class.decodeArray(decodeJsonSceneSpec))($22));
  });
  exports["ConfigSpec"] = ConfigSpec;
  exports["KeyframeSpec"] = KeyframeSpec;
  exports["SceneSpec"] = SceneSpec;
  exports["StyleSpec"] = StyleSpec;
  exports["decodeJsonStyleSpec"] = decodeJsonStyleSpec;
  exports["decodeJsonKeyframeSpec"] = decodeJsonKeyframeSpec;
  exports["decodeJsonSceneSpec"] = decodeJsonSceneSpec;
  exports["newtypeConfigSpec"] = newtypeConfigSpec;
  exports["decodeJsonConfigSpec"] = decodeJsonConfigSpec;
})(PS["Perusal.Config.Parser.Types"] = PS["Perusal.Config.Parser.Types"] || {});
(function(exports) {
    "use strict";
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Bind = PS["Control.Bind"];
  var Control_Monad_Eff = PS["Control.Monad.Eff"];
  var Control_Monad_Eff_Class = PS["Control.Monad.Eff.Class"];
  var Control_Monad_Error_Class = PS["Control.Monad.Error.Class"];
  var Control_MonadZero = PS["Control.MonadZero"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var DOM = PS["DOM"];
  var DOM_Classy_Node = PS["DOM.Classy.Node"];
  var DOM_Classy_ParentNode = PS["DOM.Classy.ParentNode"];
  var DOM_Node_NodeList = PS["DOM.Node.NodeList"];
  var DOM_Node_ParentNode = PS["DOM.Node.ParentNode"];
  var DOM_Node_Types = PS["DOM.Node.Types"];
  var Data_Chain = PS["Data.Chain"];
  var Data_EuclideanRing = PS["Data.EuclideanRing"];
  var Data_Foldable = PS["Data.Foldable"];
  var Data_Function = PS["Data.Function"];
  var Data_Functor = PS["Data.Functor"];
  var Data_Int = PS["Data.Int"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_Newtype = PS["Data.Newtype"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Ring = PS["Data.Ring"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_StrMap = PS["Data.StrMap"];
  var Data_Traversable = PS["Data.Traversable"];
  var Data_Tuple = PS["Data.Tuple"];
  var Data_Unfoldable = PS["Data.Unfoldable"];
  var Easing = PS["Easing"];
  var Perusal_Config_Parser_Types = PS["Perusal.Config.Parser.Types"];
  var Prelude = PS["Prelude"];

  // | Newtype all the things! Just to make it absolutely clear that

  // | we're talking about milliseconds, not seconds, let's wrap up the

  // | value in a delightful little overcoat.
  var Milliseconds = function (x) {
      return x;
  };

  // | Styles are fun, but we need to *animate*! In order to do that, we

  // | need an animation `duration`, and a list of `Styler` values. As

  // | time passes, we use `duration` and that time to track *progress*,

  // | which we use for the `Styler` functions.
  var Keyframe = function (x) {
      return x;
  };

  // | Scenes are like your traditional presentation "slides": each one

  // | has a set of animation keyframes and we play them in order as the

  // | user clicks back and forth. Oh, y'all wanted a *twist*? You can

  // | include animations within keyframes that happen *outside* the

  // | scenes. This is pretty useful if you want animations to run over

  // | all your slides and don't like duplicating logic.
  var Scene = function (x) {
      return x;
  };

  // | A `Config` for a presentation is just an array of `Scene`s. I

  // | can't understate how unremarkable this is.
  var Config = function (x) {
      return x;
  };

  // | Reverse the animation functions within a keyframe. This is how we

  // | animate a backwards movement! Nothing too fancy, so don't dwell

  // | too much on this one!
  var reverse = function (v) {
    
      // `progress` now goes backwards from 1 to 0! Two `map`s: one to

      // get to the `Styler`, then another to get to `Number -> Style`.
  var styles = Data_Functor.map(Data_Functor.functorArray)(Data_Functor.map(Data_Tuple.functorTuple)(function (v1) {
          return function ($69) {
              return v1((function (v2) {
                  return 1.0 - v2;
              })($69));
          };
      }))(v.styles);
      var $38 = {};
      for (var $39 in v) {
          if ({}.hasOwnProperty.call(v, $39)) {
              $38[$39] = v[$39];
          };
      };
      $38.styles = styles;
      return $38;
  };        
  var newtypeMilliseconds = new Data_Newtype.Newtype(function (n) {
      return n;
  }, Milliseconds);
  var newtypeConfig = new Data_Newtype.Newtype(function (n) {
      return n;
  }, Config);

  // | *You*: _"I have a StyleSpec... how do I get a style?"_

  // | *Me*: `fromStyleSpec`, of course! This will take our StyleSpec

  // | and produce a function that, given progress (between 0 and 1),

  // | will produce the `Style` for that moment. We use a standard

  // | "quadratic" easing for JSON input (shout-out to Robert Penner),

  // | which can be swapped out for something way more interesting if we

  // | stay away from JSON. *Write PureScript*; I dare ya!
  var fromStyleSpec = function (v) {
      return function (progress) {
        
          // Convert a `StyleSpec` tuple to a polynomial easing.
  var ease = Data_Tuple.uncurry(Easing.polynomial(2.0));
          return {
              opacity: ease(v.opacity)(progress), 
              rotate: ease(v.rotate)(progress), 
              scale: ease(v.scale)(progress), 
              translateX: ease(v.translateX)(progress), 
              translateY: ease(v.translateY)(progress)
          };
      };
  };

  // | We have a `Keyframe` to produce! Firstly, we're going to need a

  // | `document` to use as a parent node. Panic not: we'll probably use

  // | the `document` object, and you'll never need be any the wiser! :D
  var fromKeyframeSpec = function (dictIsParentNode) {
      return function (dictMonadError) {
          return function (dictMonadEff) {
              return function (document) {
                  return function (v) {
                      var prepare = function (v1) {
                          return Control_Bind.bind((dictMonadEff.Monad0()).Bind1())(Control_Monad_Eff_Class.liftEff(dictMonadEff)(Control_Bind.bind(Control_Monad_Eff.bindEff)(DOM_Classy_ParentNode.querySelectorAll(dictIsParentNode)(Data_Newtype.wrap(DOM_Node_ParentNode.newtypeQuerySelector)(v1.value0))(document))(DOM_Node_NodeList.toArray)))(function (v2) {
                              var v3 = Data_Traversable.traverse(Data_Traversable.traversableArray)(Data_Maybe.applicativeMaybe)(DOM_Classy_Node.fromNode(DOM_Classy_Node.isNodeElement))(v2);
                              if (v3 instanceof Data_Maybe.Just) {
                                  return Control_Applicative.pure((dictMonadEff.Monad0()).Applicative0())(new Data_Tuple.Tuple(v3.value0, fromStyleSpec(v1.value1)));
                              };
                              if (v3 instanceof Data_Maybe.Nothing) {
                                  return Control_Monad_Error_Class.throwError(dictMonadError.MonadThrow0())("Keyframes contain non-elements!");
                              };
                              throw new Error("Failed pattern match at Perusal.Config.Types line 139, column 7 - line 144, column 1: " + [ v3.constructor.name ]);
                          });
                      };
                      var duration = (function () {
                          var $56 = v.duration < 0;
                          if ($56) {
                              return Control_Monad_Error_Class.throwError(dictMonadError.MonadThrow0())("Negative duration!");
                          };
                          return Control_Applicative.pure((dictMonadEff.Monad0()).Applicative0())(v.duration);
                      })();
                      return Data_Functor.map((((dictMonadEff.Monad0()).Bind1()).Apply0()).Functor0())(Keyframe)(Control_Apply.apply(((dictMonadEff.Monad0()).Bind1()).Apply0())(Data_Functor.map((((dictMonadEff.Monad0()).Bind1()).Apply0()).Functor0())(function (v1) {
                          return function (v2) {
                              return {
                                  duration: v1, 
                                  styles: v2
                              };
                          };
                      })(duration))(Data_Traversable.traverse(Data_Traversable.traversableArray)((dictMonadEff.Monad0()).Applicative0())(prepare)(Data_StrMap.toUnfoldable(Data_Unfoldable.unfoldableArray)(v.styles))));
                  };
              };
          };
      };
  };

  // | To produce a `Scene` from a `SceneSpec`, we're going to need to

  // | convert the `KeyframeSpec`s to `Keyframe`s _and_ get the element

  // | selected by `container`. It's all a bit... `Applicative`.
  var fromSceneSpec = function (dictIsParentNode) {
      return function (dictMonadError) {
          return function (dictMonadEff) {
              return function (document) {
                  return function (v) {
                      var liftMaybe = function (error) {
                          return Data_Maybe.maybe(Control_Monad_Error_Class.throwError(dictMonadError.MonadThrow0())(error))(Control_Applicative.pure((dictMonadEff.Monad0()).Applicative0()));
                      };
                      var keyframes$prime = Data_Traversable.traverse(Data_Traversable.traversableArray)((dictMonadEff.Monad0()).Applicative0())(fromKeyframeSpec(dictIsParentNode)(dictMonadError)(dictMonadEff)(document))(v.keyframes);
                      var container$prime = Control_Bind.bind((dictMonadEff.Monad0()).Bind1())(Control_Monad_Eff_Class.liftEff(dictMonadEff)(DOM_Classy_ParentNode.querySelector(dictIsParentNode)(Data_Newtype.wrap(DOM_Node_ParentNode.newtypeQuerySelector)(v.container))(document)))(liftMaybe("Can't find " + (v.container + "!")));
                      return Data_Functor.map((((dictMonadEff.Monad0()).Bind1()).Apply0()).Functor0())(Scene)(Control_Apply.apply(((dictMonadEff.Monad0()).Bind1()).Apply0())(Data_Functor.map((((dictMonadEff.Monad0()).Bind1()).Apply0()).Functor0())(function (v1) {
                          return function (v2) {
                              return {
                                  container: v1, 
                                  keyframes: v2
                              };
                          };
                      })(container$prime))(keyframes$prime));
                  };
              };
          };
      };
  };

  // | Oooh wow, you've gone *full JSON*, haven't you? _Well_, as luck

  // | would have it, this function is the last we have in stock. This

  // | function will fully translate a `ConfigSpec` into `Config`. It's

  // | pretty neat, right?
  var fromConfigSpec = function (dictIsParentNode) {
      return function (dictMonadError) {
          return function (dictMonadEff) {
              return function (doc) {
                  return function ($70) {
                      return Data_Functor.map((((dictMonadEff.Monad0()).Bind1()).Apply0()).Functor0())(Data_Newtype.wrap(newtypeConfig))(Data_Traversable.traverse(Data_Traversable.traversableArray)((dictMonadEff.Monad0()).Applicative0())(fromSceneSpec(dictIsParentNode)(dictMonadError)(dictMonadEff)(doc))(Data_Newtype.unwrap(Perusal_Config_Parser_Types.newtypeConfigSpec)($70)));
                  };
              };
          };
      };
  };

  // | `Styler` values are fun, but, sooner or later, we'll want to fix

  // | them to a given value. To do this, we take the `Milliseconds`

  // | elapsed since our animation "started", and use that to calculate

  // | our `progress`. If the animation is running, we can return a

  // | `Renderable`; if it isn't, we panic, freak out, and run away.
  var freeze = function (elapsed) {
      return function (v) {
          var progress = Data_Int.toNumber(Data_Newtype.unwrap(newtypeMilliseconds)(elapsed)) / Data_Int.toNumber(Data_Newtype.unwrap(newtypeMilliseconds)(v.duration));
          return Data_Functor.voidLeft(Data_Maybe.functorMaybe)(Control_MonadZero.guard(Data_Maybe.monadZeroMaybe)(Data_Ord.between(Data_Ord.ordNumber)(0.0)(1.0)(progress)))(Data_Functor.map(Data_Functor.functorArray)(function (v1) {
              return Data_Functor.flap(Data_Tuple.functorTuple)(v1)(progress);
          })(v.styles));
      };
  };

  // | Take a `Scene`, produce a list of `Tuple Element Keyframe`. This

  // | is how we turn a `Config` into something we can actually animate:

  // | produce this tuple list, then put that into a `Chain`. All we

  // | then need is a way of fixing the keyframe to a given progress...

  // | `freeze`-ing it, if you will... and we're away!
  var flatten = function (v) {
      return Data_Functor.map(Data_Functor.functorArray)(Data_Tuple.Tuple.create(v.container))(v.keyframes);
  };

  // | Nice `Config` you got there. It'd look better as a `Chain`,

  // | though, wouldn't it? _Shh_, tell no one, but this function will

  // | sort that right out. This is a way more useful function than just

  // | `flatten` on its own.
  var toChain = function (v) {
      return Data_Chain.fromFoldable(Data_Foldable.foldableArray)(Control_Bind.bind(Control_Bind.bindArray)(v)(flatten));
  };
  exports["Config"] = Config;
  exports["Keyframe"] = Keyframe;
  exports["Milliseconds"] = Milliseconds;
  exports["Scene"] = Scene;
  exports["flatten"] = flatten;
  exports["freeze"] = freeze;
  exports["fromConfigSpec"] = fromConfigSpec;
  exports["fromKeyframeSpec"] = fromKeyframeSpec;
  exports["fromSceneSpec"] = fromSceneSpec;
  exports["fromStyleSpec"] = fromStyleSpec;
  exports["reverse"] = reverse;
  exports["toChain"] = toChain;
  exports["newtypeMilliseconds"] = newtypeMilliseconds;
  exports["newtypeConfig"] = newtypeConfig;
})(PS["Perusal.Config.Types"] = PS["Perusal.Config.Types"] || {});
(function(exports) {
    "use strict";
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Monad_Eff = PS["Control.Monad.Eff"];
  var Control_Monad_Eff_Class = PS["Control.Monad.Eff.Class"];
  var DOM = PS["DOM"];
  var DOM_Node_Element = PS["DOM.Node.Element"];
  var Data_Foldable = PS["Data.Foldable"];
  var Data_Function = PS["Data.Function"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Semiring = PS["Data.Semiring"];
  var Data_Show = PS["Data.Show"];
  var Data_Tuple = PS["Data.Tuple"];
  var Data_Unit = PS["Data.Unit"];
  var $$Math = PS["Math"];
  var Perusal_Config_Types = PS["Perusal.Config.Types"];
  var Prelude = PS["Prelude"];        

  // | When all is said and all is done, we still need to turn a `Style`

  // | into CSS to attach it to the elements. It doesn't feel right to

  // | use `Show` here, as we'd probably want a clearer representation,

  // | so we'll write this little scamp. Take a `Style`, make a CSS.
  var toCSS = function (v) {
      return "opacity: " + (Data_Show.show(Data_Show.showNumber)(v.opacity) + ("; " + ("transform: " + ("translate2d(" + (Data_Show.show(Data_Show.showNumber)(v.translateX) + (", " + (Data_Show.show(Data_Show.showNumber)(v.translateY) + (") " + ("rotate(" + (Data_Show.show(Data_Show.showNumber)(v.rotate * 2.0 * $$Math.pi) + ("rad) " + ("scale(" + (Data_Show.show(Data_Show.showNumber)(v.scale) + ")")))))))))))));
  };

  // | Ignore the `group` and `set` here if it's scary; chances are that

  // | you'll use `Array` for both! This function takes a list of

  // | `Element` / `Style` groups, and... well, it styles the elements.
  var render = function (dictMonadEff) {
      return function (v) {
          var hide = function (v1) {
              if (v1 instanceof Data_Maybe.Just) {
                  return DOM_Node_Element.setAttribute("style")("display: none")(v1.value0.value0);
              };
              if (v1 instanceof Data_Maybe.Nothing) {
                  return Control_Applicative.pure(Control_Monad_Eff.applicativeEff)(Data_Unit.unit);
              };
              throw new Error("Failed pattern match at Perusal.HTML line 43, column 5 - line 43, column 69: " + [ v1.constructor.name ]);
          };
          return Control_Monad_Eff_Class.liftEff(dictMonadEff)(Control_Apply.applySecond(Control_Monad_Eff.applyEff)(Control_Apply.applySecond(Control_Monad_Eff.applyEff)(hide(v.last))(DOM_Node_Element.setAttribute("style")("")(v.now.value0)))(Data_Foldable.for_(Control_Monad_Eff.applicativeEff)(Data_Foldable.foldableArray)(v.now.value1)(function (v1) {
              return Data_Foldable.for_(Control_Monad_Eff.applicativeEff)(Data_Foldable.foldableArray)(v1.value0)(DOM_Node_Element.setAttribute("style")(toCSS(v1.value1)));
          })));
      };
  };
  exports["render"] = render;
})(PS["Perusal.HTML"] = PS["Perusal.HTML"] || {});
(function(exports) {
    "use strict";
  var Control_Alt = PS["Control.Alt"];
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Category = PS["Control.Category"];
  var Control_Monad_Eff = PS["Control.Monad.Eff"];
  var Control_Monad_Eff_Class = PS["Control.Monad.Eff.Class"];
  var Control_Monad_Reader_Class = PS["Control.Monad.Reader.Class"];
  var Control_MonadZero = PS["Control.MonadZero"];
  var Data_Boolean = PS["Data.Boolean"];
  var Data_Function = PS["Data.Function"];
  var Data_Functor = PS["Data.Functor"];
  var Data_HeytingAlgebra = PS["Data.HeytingAlgebra"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Ring = PS["Data.Ring"];
  var Data_Set = PS["Data.Set"];
  var Data_Tuple = PS["Data.Tuple"];
  var FRP = PS["FRP"];
  var FRP_Event = PS["FRP.Event"];
  var FRP_Event_Keyboard = PS["FRP.Event.Keyboard"];
  var FRP_Event_Time = PS["FRP.Event.Time"];
  var Prelude = PS["Prelude"];        

  // | Supa-simple data type to generalise `fromInput` to the choice of

  // | "left" or "right". Yes, it's isomorphic to `Boolean`, but I'm

  // | gonna put code clarity above minor code optimisation.
  var Prev = (function () {
      function Prev() {

      };
      Prev.value = new Prev();
      return Prev;
  })();

  // | Supa-simple data type to generalise `fromInput` to the choice of

  // | "left" or "right". Yes, it's isomorphic to `Boolean`, but I'm

  // | gonna put code clarity above minor code optimisation.
  var Next = (function () {
      function Next() {

      };
      Next.value = new Next();
      return Next;
  })();

  // | When you use `withLast` on a `Maybe` stream, you probably don't

  // | get the desired behaviour. _This_ function is `withLast`, but will

  // | give you the `last` that was a `Just`!
  var withLastJust = function (e) {
      return Control_Alt.alt(FRP_Event.altEvent)(Data_Functor.voidLeft(FRP_Event.functorEvent)(FRP_Event.filter(Data_Maybe.isNothing)(e))(Data_Maybe.Nothing.value))(Data_Functor.map(FRP_Event.functorEvent)(Control_Applicative.pure(Data_Maybe.applicativeMaybe))(FRP_Event.withLast(FRP_Event.mapMaybe(Control_Category.id(Control_Category.categoryFn))(e))));
  };

  // | Here's an interesting problem to solve: you have an event being

  // | sampled according to the tick of a second stream. You get results

  // | back, but you have no idea _when_ they happened; with this little

  // | menace, we can solve that little problem.
  var withDelay = function (sampler) {
      return function (e) {
        
          // Calculate a duration!
  var go = function (v) {
              return new Data_Tuple.Tuple(v.time - v.value.time | 0, v.value.value);
          };
          return Data_Functor.map(FRP_Event.functorEvent)(go)(FRP_Event_Time.withTime(FRP_Event.sampleOn_(FRP_Event_Time.withTime(e))(sampler)));
      };
  };

  // | Filter out events from a stream that occur while a `Boolean` behavior is

  // | `false`.
  var when = function (ps) {
      return function (xs) {
          return FRP_Event.mapMaybe(Control_Category.id(Control_Category.categoryFn))(Control_Apply.apply(FRP_Event.applyEvent)(Data_Functor.map(FRP_Event.functorEvent)(function (p) {
              return function (x) {
                  return Data_Functor.voidLeft(Data_Maybe.functorMaybe)(Control_MonadZero.guard(Data_Maybe.monadZeroMaybe)(p))(x);
              };
          })(ps))(xs));
      };
  };

  // | Create an event that can block itself. This is pretty exciting if

  // | you want to, say, disable key presses during an animation...
  var withBlocking = function (dictMonadEff) {
      return function (action) {
          return Data_Functor.mapFlipped((((dictMonadEff.Monad0()).Bind1()).Apply0()).Functor0())(Control_Monad_Eff_Class.liftEff(dictMonadEff)(FRP_Event.create))(function (ks) {
              var $13 = {};
              for (var $14 in ks) {
                  if ({}.hasOwnProperty.call(ks, $14)) {
                      $13[$14] = ks[$14];
                  };
              };
              $13.event = when(ks.event)(action);
              return $13;
          });
      };
  };

  // | Map over an event, but carry an accumulator value with you. This

  // | can be pretty useful if, for example, you want to attach IDs to

  // | events: `mapAccum (\x i -> Tuple (i + 1) (Tuple x i)) 0`.
  var mapAccum = function (f) {
      return function (xs) {
          return function (acc) {
              return FRP_Event.mapMaybe(Data_Tuple.snd)(FRP_Event.fold(function (a) {
                  return function (v) {
                      return Data_Functor.map(Data_Tuple.functorTuple)(Control_Applicative.pure(Data_Maybe.applicativeMaybe))(f(a)(v.value0));
                  };
              })(xs)(new Data_Tuple.Tuple(acc, Data_Maybe.Nothing.value)));
          };
      };
  };

  // | This little rascal tells us if any directional keys are being

  // | pressed, and, if so, whether they correspond to `Next` or `Prev`.

  // | Note the `MonadReader m` - we query the "global config" for our

  // | key sets here.
  var fromInput = function (dictMonadReader) {
      var go = function (prev) {
          return function (next) {
              return function (key) {
                  if (Data_Set.member(Data_Ord.ordInt)(key)(prev)) {
                      return new Data_Maybe.Just(Prev.value);
                  };
                  if (Data_Set.member(Data_Ord.ordInt)(key)(next)) {
                      return new Data_Maybe.Just(Next.value);
                  };
                  if (Data_Boolean.otherwise) {
                      return Data_Maybe.Nothing.value;
                  };
                  throw new Error("Failed pattern match at Perusal.Navigation.Controls line 40, column 5 - line 43, column 36: " + [ prev.constructor.name, next.constructor.name, key.constructor.name ]);
              };
          };
      };
      return Data_Functor.mapFlipped(((((dictMonadReader.MonadAsk0()).Monad0()).Bind1()).Apply0()).Functor0())(Control_Monad_Reader_Class.ask(dictMonadReader.MonadAsk0()))(function (v) {
          return FRP_Event.mapMaybe(go(v.prev)(v.next))(FRP_Event_Keyboard.down);
      });
  };

  // | Chances are that you _don't_ want a `Direction`, and you're

  // | really more interested in another type. Well, now's your

  // | chance to shine. *Go get 'em, tiger*.
  var fromDirection = function (prev) {
      return function (next) {
          return function (v) {
              if (v instanceof Prev) {
                  return prev;
              };
              if (v instanceof Next) {
                  return next;
              };
              throw new Error("Failed pattern match at Perusal.Navigation.Controls line 50, column 27 - line 51, column 49: " + [ v.constructor.name ]);
          };
      };
  };
  exports["Prev"] = Prev;
  exports["Next"] = Next;
  exports["fromDirection"] = fromDirection;
  exports["fromInput"] = fromInput;
  exports["mapAccum"] = mapAccum;
  exports["when"] = when;
  exports["withBlocking"] = withBlocking;
  exports["withDelay"] = withDelay;
  exports["withLastJust"] = withLastJust;
})(PS["Perusal.Navigation.Controls"] = PS["Perusal.Navigation.Controls"] || {});
(function(exports) {
    "use strict";
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Bind = PS["Control.Bind"];
  var Control_Category = PS["Control.Category"];
  var Control_Monad_Eff = PS["Control.Monad.Eff"];
  var Control_Monad_Eff_Class = PS["Control.Monad.Eff.Class"];
  var Control_Monad_Error_Class = PS["Control.Monad.Error.Class"];
  var Control_Monad_Except_Trans = PS["Control.Monad.Except.Trans"];
  var Control_Monad_Reader_Class = PS["Control.Monad.Reader.Class"];
  var Control_Monad_Reader_Trans = PS["Control.Monad.Reader.Trans"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var DOM = PS["DOM"];
  var DOM_Classy_ParentNode = PS["DOM.Classy.ParentNode"];
  var DOM_HTML = PS["DOM.HTML"];
  var DOM_HTML_Types = PS["DOM.HTML.Types"];
  var DOM_HTML_Window = PS["DOM.HTML.Window"];
  var DOM_Node_Types = PS["DOM.Node.Types"];
  var Data_Argonaut_Core = PS["Data.Argonaut.Core"];
  var Data_Argonaut_Decode_Class = PS["Data.Argonaut.Decode.Class"];
  var Data_Chain = PS["Data.Chain"];
  var Data_Either = PS["Data.Either"];
  var Data_Function = PS["Data.Function"];
  var Data_Functor = PS["Data.Functor"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_Set = PS["Data.Set"];
  var Data_Traversable = PS["Data.Traversable"];
  var Data_Tuple = PS["Data.Tuple"];
  var FRP = PS["FRP"];
  var FRP_Event = PS["FRP.Event"];
  var FRP_Event_Time = PS["FRP.Event.Time"];
  var Perusal_Config_Parser_Types = PS["Perusal.Config.Parser.Types"];
  var Perusal_Config_Types = PS["Perusal.Config.Types"];
  var Perusal_HTML = PS["Perusal.HTML"];
  var Perusal_Navigation_Controls = PS["Perusal.Navigation.Controls"];
  var Prelude = PS["Prelude"];        
  var parse = function (dictIsParentNode) {
      return function (dictMonadEff) {
          return function (dictMonadError) {
              return function (document) {
                  return Control_Bind.composeKleisli((dictMonadEff.Monad0()).Bind1())(function ($24) {
                      return Data_Either.either(Control_Monad_Error_Class.throwError(dictMonadError.MonadThrow0()))(Control_Applicative.pure((dictMonadEff.Monad0()).Applicative0()))(Data_Argonaut_Decode_Class.decodeJson(Perusal_Config_Parser_Types.decodeJsonConfigSpec)($24));
                  })(Perusal_Config_Types.fromConfigSpec(dictIsParentNode)(dictMonadError)(dictMonadEff)(document));
              };
          };
      };
  };

  // | With all the other stuff out the way, we can get to the *main

  // | event*. This function turns a `Chain` into a keyboard-sensitive

  // | `Event`, returning the `Keyframe` to animate the movement. Note

  // | that this is actually *effectful*, as we need to produce a new

  // | event to handle the status of the animation queue. Within this

  // | function, `event` is a Bool event stream indicating whether the

  // | animation queue be free.
  var animate = function (dictMonadEff) {
      return function (dictMonadReader) {
          return function (config) {
              return Control_Bind.bind((dictMonadEff.Monad0()).Bind1())(Control_Bind.bind((dictMonadEff.Monad0()).Bind1())(Perusal_Navigation_Controls.fromInput(dictMonadReader))(Perusal_Navigation_Controls.withBlocking(dictMonadEff)))(function (v) {
                
                  // Convert a `Config` to a `Chain`, create an event that yields

                  // the frames that we move over, remove the invalid steps!
  var left$prime = function (dictFunctor) {
                      return Data_Functor.map(Data_Functor.functorFn)(Data_Functor.map(Data_Maybe.functorMaybe)(Data_Functor.map(Data_Tuple.functorTuple)(Data_Functor.map(dictFunctor)(Perusal_Config_Types.reverse))))(Data_Chain.left);
                  };
                  var go = function (f) {
                      return function (cs) {
                          return Data_Maybe.maybe(new Data_Tuple.Tuple(cs, Data_Maybe.Nothing.value))(Data_Functor.map(Data_Tuple.functorTuple)(Data_Maybe.Just.create))(f(cs));
                      };
                  };
                  var navigation = FRP_Event.mapMaybe(Control_Category.id(Control_Category.categoryFn))(Perusal_Navigation_Controls.mapAccum(go)(Data_Functor.map(FRP_Event.functorEvent)(Perusal_Navigation_Controls.fromDirection(left$prime(Data_Tuple.functorTuple))(Data_Chain.right))(v.event))(Perusal_Config_Types.toChain(config)));
                  var navigation$prime = Data_Functor.map(FRP_Event.functorEvent)(function ($25) {
                      return Data_Traversable.sequence(Data_Tuple.traversableTuple)(Data_Maybe.applicativeMaybe)((function (v1) {
                          return Data_Functor.map(Data_Tuple.functorTuple)(Perusal_Config_Types.freeze(v1.value0))(v1.value1);
                      })($25));
                  })(Perusal_Navigation_Controls.withDelay(FRP_Event_Time.animationFrame)(navigation));
                  return Control_Bind.discard(Control_Bind.discardUnit)((dictMonadEff.Monad0()).Bind1())(Control_Monad_Eff_Class.liftEff(dictMonadEff)(FRP_Event.subscribe(Perusal_Navigation_Controls.withLastJust(navigation$prime))(Data_Maybe.maybe(v.push(true))(Control_Bind.composeKleisli(Control_Monad_Eff.bindEff)(Perusal_HTML.render(Control_Monad_Eff_Class.monadEffEff))(function (v1) {
                      return v.push(false);
                  })))))(function () {
                      return Control_Monad_Eff_Class.liftEff(dictMonadEff)(v.push(true));
                  });
              });
          };
      };
  };

  // | Well, well, well... Look who decided to join the party! Happy to

  // | have you :) If you're using _this_ function, you've written some

  // | PureScript! All you need is `main = fromConfig ...`, where `...`

  // | is your big `Config` value. Simples :)
  var fromConfig = function (config) {
      return Control_Monad_Reader_Trans.runReaderT(animate(Control_Monad_Reader_Trans.monadEffReader(Control_Monad_Eff_Class.monadEffEff))(Control_Monad_Reader_Trans.monadReaderReaderT(Control_Monad_Eff.monadEff))(config))({
          prev: Data_Set.singleton(37), 
          next: Data_Set.singleton(39)
      });
  };
  var fromJS = function (json) {
      return function __do() {
          var v = DOM_HTML.window();
          var v1 = Data_Functor.map(Control_Monad_Eff.functorEff)(DOM_HTML_Types.htmlDocumentToDocument)(DOM_HTML_Window.document(v))();
          var v2 = Control_Monad_Except_Trans.runExceptT(parse(DOM_Classy_ParentNode.isParentNodeDocument)(Control_Monad_Except_Trans.monadEffExceptT(Control_Monad_Eff_Class.monadEffEff))(Control_Monad_Except_Trans.monadErrorExceptT(Control_Monad_Eff.monadEff))(v1)(json))();
          if (v2 instanceof Data_Either.Right) {
              return fromConfig(v2.value0)();
          };
          if (v2 instanceof Data_Either.Left) {
              return DOM_HTML_Window.alert(v2.value0)(v)();
          };
          throw new Error("Failed pattern match at Perusal.Main line 51, column 3 - line 52, column 51: " + [ v2.constructor.name ]);
      };
  };
  exports["fromConfig"] = fromConfig;
  exports["fromJS"] = fromJS;
})(PS["Perusal.Main"] = PS["Perusal.Main"] || {});
module.exports = PS["Perusal.Main"];

},{}]},{},[1])(1)
});